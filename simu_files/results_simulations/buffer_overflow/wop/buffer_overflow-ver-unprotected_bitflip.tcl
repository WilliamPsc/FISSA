#############  INIT SIMULATIONS #############
set regs_file /home/wpensec/Documents/DRiSCY/pulpino/sw/build/apps/buffer_overflow/CMakeFiles/buffer_overflow.vsimc.dir/buffer_overflow-ver-unprotected_bitflip/faulted-reg.yaml
set state_file /home/wpensec/Documents/DRiSCY/pulpino/sw/build/apps/buffer_overflow/CMakeFiles/buffer_overflow.vsimc.dir/buffer_overflow-ver-unprotected_bitflip/buffer_overflow-ver-unprotected_bitflip.json
set f [open $state_file w]
puts $f "{"
puts $f "\t\"start\": \"[clock format [clock seconds] -format "%Y/%m/%d:%H:%M:%S"]\","
close $f

set f [open $regs_file r]
set reg_file_data [read $f]
close $f

###### INIT VARIABLES ######
### CONTROL ###
set periode 40
set half_periode 20
set start 137140
set nb_sim 0  ;# Numéro de la simulation
set sim_active 1 ;# Booléen de sim active
set cycle_ref 100 ;# Fixation du nombre de cycle de référence de la simulation complète
set cycle_curr 0

### FAULTED REGISTER ###
set threat ""
set width_threat 0
set faulted_register ""

### DETECTED ERRORS ###
set value_end_pc 0
set cycle_ill_insn ""

### STATUS END ###
set status_end -1 ;# Code de fin de simulation (0: simulation correcte / 1: dépassement du nombre de cycle de référence / 2: saut vers le gestionnaire d'instruction illégale / 3: saut vers le gestionnaire d'instruction illégale / 4 : valeur du PC erronée / ...)


#############  FIRST SIM #############
###### JUMP TO ATTACK START ######
run "$start ns" ;# Saut vers la fenêtre d'attaque

##---------------------
while {$cycle_curr <= $cycle_ref} {
    incr cycle_curr
    run "$periode ns"
    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]
    set value_insn_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]
    if {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {$value_insn_pc} == {"32'hfa010113"}])} {
        set cycle_ill_insn [expr $now / 1000]
    }
}

echo $cycle_ill_insn

#############  CHECKING SIM VALUES #############
## CHECK ENDING CYCLE ##
set check_cycle [expr [expr $now / 1000 - $start] / 40] ;# Vérification du numéro du cycle actuel
set value_end_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]
set status_end 0
set cycle_curr 0

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 0 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 1 #############
###### JUMP TO ATTACK START ######
set start_sim "137140 ns"
run "137140 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137140 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 1
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o_tag
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 0
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 1 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 2 #############
###### JUMP TO ATTACK START ######
set start_sim "137180 ns"
run "137180 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137180 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 1
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o_tag
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 0
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 2 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 3 #############
###### JUMP TO ATTACK START ######
set start_sim "137220 ns"
run "137220 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137220 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 1
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o_tag
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 0
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 3 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 4 #############
###### JUMP TO ATTACK START ######
set start_sim "137260 ns"
run "137260 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137260 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 1
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o_tag
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 0
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 4 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 5 #############
###### JUMP TO ATTACK START ######
set start_sim "137300 ns"
run "137300 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137300 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 1
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o_tag
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 0
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 5 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 6 #############
###### JUMP TO ATTACK START ######
set start_sim "137340 ns"
run "137340 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137340 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 1
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o_tag
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 0
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 6 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 7 #############
###### JUMP TO ATTACK START ######
set start_sim "137140 ns"
run "137140 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137140 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 1
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_if_o_tag
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 0
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 7 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 8 #############
###### JUMP TO ATTACK START ######
set start_sim "137180 ns"
run "137180 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137180 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 1
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_if_o_tag
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 0
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 8 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 9 #############
###### JUMP TO ATTACK START ######
set start_sim "137220 ns"
run "137220 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137220 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 1
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_if_o_tag
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 0
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 9 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 10 #############
###### JUMP TO ATTACK START ######
set start_sim "137260 ns"
run "137260 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137260 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 1
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_if_o_tag
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 0
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 10 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 11 #############
###### JUMP TO ATTACK START ######
set start_sim "137300 ns"
run "137300 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137300 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 1
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_if_o_tag
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 0
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 11 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 12 #############
###### JUMP TO ATTACK START ######
set start_sim "137340 ns"
run "137340 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137340 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 1
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_if_o_tag
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 0
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 12 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 13 #############
###### JUMP TO ATTACK START ######
set start_sim "137140 ns"
run "137140 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137140 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 1
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/alu_operand_a_ex_o_tag
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 0
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 13 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 14 #############
###### JUMP TO ATTACK START ######
set start_sim "137180 ns"
run "137180 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137180 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 1
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/alu_operand_a_ex_o_tag
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 0
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 14 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 15 #############
###### JUMP TO ATTACK START ######
set start_sim "137220 ns"
run "137220 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137220 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 1
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/alu_operand_a_ex_o_tag
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 0
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 15 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 16 #############
###### JUMP TO ATTACK START ######
set start_sim "137260 ns"
run "137260 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137260 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 1
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/alu_operand_a_ex_o_tag
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 0
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 16 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 17 #############
###### JUMP TO ATTACK START ######
set start_sim "137300 ns"
run "137300 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137300 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 1
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/alu_operand_a_ex_o_tag
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 0
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 17 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 18 #############
###### JUMP TO ATTACK START ######
set start_sim "137340 ns"
run "137340 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137340 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 1
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/alu_operand_a_ex_o_tag
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 0
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 18 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 19 #############
###### JUMP TO ATTACK START ######
set start_sim "137140 ns"
run "137140 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137140 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 1
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/alu_operand_b_ex_o_tag
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 0
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 19 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 20 #############
###### JUMP TO ATTACK START ######
set start_sim "137180 ns"
run "137180 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137180 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 1
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/alu_operand_b_ex_o_tag
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 0
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 20 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 21 #############
###### JUMP TO ATTACK START ######
set start_sim "137220 ns"
run "137220 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137220 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 1
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/alu_operand_b_ex_o_tag
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 0
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 21 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 22 #############
###### JUMP TO ATTACK START ######
set start_sim "137260 ns"
run "137260 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137260 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 1
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/alu_operand_b_ex_o_tag
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 0
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 22 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 23 #############
###### JUMP TO ATTACK START ######
set start_sim "137300 ns"
run "137300 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137300 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 1
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/alu_operand_b_ex_o_tag
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 0
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 23 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 24 #############
###### JUMP TO ATTACK START ######
set start_sim "137340 ns"
run "137340 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137340 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 1
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/alu_operand_b_ex_o_tag
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 0
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 24 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 25 #############
###### JUMP TO ATTACK START ######
set start_sim "137140 ns"
run "137140 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137140 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 1
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/alu_operand_c_ex_o_tag
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 0
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 25 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 26 #############
###### JUMP TO ATTACK START ######
set start_sim "137180 ns"
run "137180 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137180 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 1
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/alu_operand_c_ex_o_tag
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 0
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 26 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 27 #############
###### JUMP TO ATTACK START ######
set start_sim "137220 ns"
run "137220 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137220 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 1
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/alu_operand_c_ex_o_tag
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 0
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 27 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 28 #############
###### JUMP TO ATTACK START ######
set start_sim "137260 ns"
run "137260 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137260 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 1
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/alu_operand_c_ex_o_tag
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 0
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 28 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 29 #############
###### JUMP TO ATTACK START ######
set start_sim "137300 ns"
run "137300 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137300 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 1
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/alu_operand_c_ex_o_tag
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 0
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 29 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 30 #############
###### JUMP TO ATTACK START ######
set start_sim "137340 ns"
run "137340 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137340 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 1
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/alu_operand_c_ex_o_tag
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 0
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 30 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 31 #############
###### JUMP TO ATTACK START ######
set start_sim "137140 ns"
run "137140 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137140 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 2
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/alu_operator_o_mode
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 0
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 31 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 32 #############
###### JUMP TO ATTACK START ######
set start_sim "137180 ns"
run "137180 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137180 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 2
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/alu_operator_o_mode
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 0
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 32 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 33 #############
###### JUMP TO ATTACK START ######
set start_sim "137220 ns"
run "137220 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137220 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 2
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/alu_operator_o_mode
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 0
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 33 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 34 #############
###### JUMP TO ATTACK START ######
set start_sim "137260 ns"
run "137260 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137260 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 2
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/alu_operator_o_mode
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 0
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 34 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 35 #############
###### JUMP TO ATTACK START ######
set start_sim "137300 ns"
run "137300 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137300 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 2
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/alu_operator_o_mode
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 0
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 35 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 36 #############
###### JUMP TO ATTACK START ######
set start_sim "137340 ns"
run "137340 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137340 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 2
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/alu_operator_o_mode
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 0
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 36 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 37 #############
###### JUMP TO ATTACK START ######
set start_sim "137140 ns"
run "137140 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137140 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 2
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/alu_operator_o_mode
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 1
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 37 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 38 #############
###### JUMP TO ATTACK START ######
set start_sim "137180 ns"
run "137180 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137180 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 2
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/alu_operator_o_mode
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 1
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 38 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 39 #############
###### JUMP TO ATTACK START ######
set start_sim "137220 ns"
run "137220 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137220 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 2
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/alu_operator_o_mode
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 1
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 39 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 40 #############
###### JUMP TO ATTACK START ######
set start_sim "137260 ns"
run "137260 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137260 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 2
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/alu_operator_o_mode
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 1
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 40 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 41 #############
###### JUMP TO ATTACK START ######
set start_sim "137300 ns"
run "137300 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137300 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 2
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/alu_operator_o_mode
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 1
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 41 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 42 #############
###### JUMP TO ATTACK START ######
set start_sim "137340 ns"
run "137340 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137340 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 2
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/alu_operator_o_mode
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 1
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 42 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 43 #############
###### JUMP TO ATTACK START ######
set start_sim "137140 ns"
run "137140 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137140 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 1
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/check_d_o_tag
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 0
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 43 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 44 #############
###### JUMP TO ATTACK START ######
set start_sim "137180 ns"
run "137180 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137180 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 1
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/check_d_o_tag
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 0
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 44 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 45 #############
###### JUMP TO ATTACK START ######
set start_sim "137220 ns"
run "137220 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137220 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 1
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/check_d_o_tag
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 0
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 45 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 46 #############
###### JUMP TO ATTACK START ######
set start_sim "137260 ns"
run "137260 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137260 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 1
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/check_d_o_tag
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 0
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 46 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 47 #############
###### JUMP TO ATTACK START ######
set start_sim "137300 ns"
run "137300 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137300 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 1
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/check_d_o_tag
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 0
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 47 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 48 #############
###### JUMP TO ATTACK START ######
set start_sim "137340 ns"
run "137340 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137340 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 1
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/check_d_o_tag
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 0
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 48 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 49 #############
###### JUMP TO ATTACK START ######
set start_sim "137140 ns"
run "137140 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137140 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 1
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/check_s1_o_tag
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 0
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 49 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 50 #############
###### JUMP TO ATTACK START ######
set start_sim "137180 ns"
run "137180 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137180 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 1
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/check_s1_o_tag
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 0
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 50 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 51 #############
###### JUMP TO ATTACK START ######
set start_sim "137220 ns"
run "137220 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137220 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 1
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/check_s1_o_tag
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 0
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 51 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 52 #############
###### JUMP TO ATTACK START ######
set start_sim "137260 ns"
run "137260 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137260 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 1
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/check_s1_o_tag
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 0
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 52 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 53 #############
###### JUMP TO ATTACK START ######
set start_sim "137300 ns"
run "137300 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137300 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 1
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/check_s1_o_tag
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 0
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 53 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 54 #############
###### JUMP TO ATTACK START ######
set start_sim "137340 ns"
run "137340 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137340 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 1
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/check_s1_o_tag
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 0
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 54 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 55 #############
###### JUMP TO ATTACK START ######
set start_sim "137140 ns"
run "137140 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137140 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 1
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/check_s2_o_tag
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 0
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 55 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 56 #############
###### JUMP TO ATTACK START ######
set start_sim "137180 ns"
run "137180 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137180 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 1
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/check_s2_o_tag
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 0
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 56 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 57 #############
###### JUMP TO ATTACK START ######
set start_sim "137220 ns"
run "137220 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137220 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 1
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/check_s2_o_tag
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 0
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 57 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 58 #############
###### JUMP TO ATTACK START ######
set start_sim "137260 ns"
run "137260 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137260 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 1
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/check_s2_o_tag
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 0
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 58 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 59 #############
###### JUMP TO ATTACK START ######
set start_sim "137300 ns"
run "137300 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137300 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 1
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/check_s2_o_tag
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 0
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 59 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 60 #############
###### JUMP TO ATTACK START ######
set start_sim "137340 ns"
run "137340 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137340 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 1
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/check_s2_o_tag
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 0
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 60 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 61 #############
###### JUMP TO ATTACK START ######
set start_sim "137140 ns"
run "137140 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137140 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 1
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/is_store_post_o_tag
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 0
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 61 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 62 #############
###### JUMP TO ATTACK START ######
set start_sim "137180 ns"
run "137180 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137180 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 1
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/is_store_post_o_tag
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 0
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 62 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 63 #############
###### JUMP TO ATTACK START ######
set start_sim "137220 ns"
run "137220 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137220 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 1
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/is_store_post_o_tag
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 0
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 63 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 64 #############
###### JUMP TO ATTACK START ######
set start_sim "137260 ns"
run "137260 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137260 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 1
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/is_store_post_o_tag
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 0
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 64 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 65 #############
###### JUMP TO ATTACK START ######
set start_sim "137300 ns"
run "137300 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137300 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 1
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/is_store_post_o_tag
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 0
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 65 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 66 #############
###### JUMP TO ATTACK START ######
set start_sim "137340 ns"
run "137340 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137340 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 1
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/is_store_post_o_tag
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 0
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 66 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 67 #############
###### JUMP TO ATTACK START ######
set start_sim "137140 ns"
run "137140 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137140 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 1
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/memory_set_o_tag
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 0
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 67 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 68 #############
###### JUMP TO ATTACK START ######
set start_sim "137180 ns"
run "137180 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137180 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 1
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/memory_set_o_tag
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 0
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 68 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 69 #############
###### JUMP TO ATTACK START ######
set start_sim "137220 ns"
run "137220 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137220 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 1
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/memory_set_o_tag
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 0
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 69 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 70 #############
###### JUMP TO ATTACK START ######
set start_sim "137260 ns"
run "137260 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137260 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 1
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/memory_set_o_tag
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 0
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 70 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 71 #############
###### JUMP TO ATTACK START ######
set start_sim "137300 ns"
run "137300 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137300 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 1
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/memory_set_o_tag
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 0
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 71 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 72 #############
###### JUMP TO ATTACK START ######
set start_sim "137340 ns"
run "137340 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137340 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 1
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/memory_set_o_tag
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 0
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 72 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 73 #############
###### JUMP TO ATTACK START ######
set start_sim "137140 ns"
run "137140 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137140 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 5
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/regfile_alu_waddr_ex_o_tag
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 0
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 73 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 74 #############
###### JUMP TO ATTACK START ######
set start_sim "137180 ns"
run "137180 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137180 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 5
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/regfile_alu_waddr_ex_o_tag
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 0
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 74 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 75 #############
###### JUMP TO ATTACK START ######
set start_sim "137220 ns"
run "137220 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137220 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 5
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/regfile_alu_waddr_ex_o_tag
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 0
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 75 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 76 #############
###### JUMP TO ATTACK START ######
set start_sim "137260 ns"
run "137260 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137260 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 5
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/regfile_alu_waddr_ex_o_tag
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 0
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 76 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 77 #############
###### JUMP TO ATTACK START ######
set start_sim "137300 ns"
run "137300 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137300 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 5
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/regfile_alu_waddr_ex_o_tag
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 0
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 77 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 78 #############
###### JUMP TO ATTACK START ######
set start_sim "137340 ns"
run "137340 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137340 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 5
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/regfile_alu_waddr_ex_o_tag
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 0
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 78 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 79 #############
###### JUMP TO ATTACK START ######
set start_sim "137140 ns"
run "137140 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137140 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 5
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/regfile_alu_waddr_ex_o_tag
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 1
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 79 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 80 #############
###### JUMP TO ATTACK START ######
set start_sim "137180 ns"
run "137180 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137180 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 5
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/regfile_alu_waddr_ex_o_tag
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 1
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 80 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 81 #############
###### JUMP TO ATTACK START ######
set start_sim "137220 ns"
run "137220 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137220 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 5
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/regfile_alu_waddr_ex_o_tag
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 1
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 81 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 82 #############
###### JUMP TO ATTACK START ######
set start_sim "137260 ns"
run "137260 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137260 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 5
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/regfile_alu_waddr_ex_o_tag
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 1
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 82 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 83 #############
###### JUMP TO ATTACK START ######
set start_sim "137300 ns"
run "137300 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137300 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 5
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/regfile_alu_waddr_ex_o_tag
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 1
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 83 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 84 #############
###### JUMP TO ATTACK START ######
set start_sim "137340 ns"
run "137340 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137340 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 5
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/regfile_alu_waddr_ex_o_tag
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 1
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 84 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 85 #############
###### JUMP TO ATTACK START ######
set start_sim "137140 ns"
run "137140 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137140 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 5
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/regfile_alu_waddr_ex_o_tag
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 2
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 85 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 86 #############
###### JUMP TO ATTACK START ######
set start_sim "137180 ns"
run "137180 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137180 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 5
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/regfile_alu_waddr_ex_o_tag
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 2
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 86 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 87 #############
###### JUMP TO ATTACK START ######
set start_sim "137220 ns"
run "137220 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137220 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 5
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/regfile_alu_waddr_ex_o_tag
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 2
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 87 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 88 #############
###### JUMP TO ATTACK START ######
set start_sim "137260 ns"
run "137260 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137260 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 5
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/regfile_alu_waddr_ex_o_tag
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 2
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 88 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 89 #############
###### JUMP TO ATTACK START ######
set start_sim "137300 ns"
run "137300 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137300 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 5
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/regfile_alu_waddr_ex_o_tag
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 2
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 89 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 90 #############
###### JUMP TO ATTACK START ######
set start_sim "137340 ns"
run "137340 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137340 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 5
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/regfile_alu_waddr_ex_o_tag
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 2
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 90 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 91 #############
###### JUMP TO ATTACK START ######
set start_sim "137140 ns"
run "137140 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137140 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 5
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/regfile_alu_waddr_ex_o_tag
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 3
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 91 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 92 #############
###### JUMP TO ATTACK START ######
set start_sim "137180 ns"
run "137180 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137180 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 5
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/regfile_alu_waddr_ex_o_tag
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 3
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 92 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 93 #############
###### JUMP TO ATTACK START ######
set start_sim "137220 ns"
run "137220 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137220 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 5
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/regfile_alu_waddr_ex_o_tag
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 3
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 93 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 94 #############
###### JUMP TO ATTACK START ######
set start_sim "137260 ns"
run "137260 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137260 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 5
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/regfile_alu_waddr_ex_o_tag
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 3
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 94 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 95 #############
###### JUMP TO ATTACK START ######
set start_sim "137300 ns"
run "137300 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137300 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 5
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/regfile_alu_waddr_ex_o_tag
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 3
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 95 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 96 #############
###### JUMP TO ATTACK START ######
set start_sim "137340 ns"
run "137340 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137340 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 5
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/regfile_alu_waddr_ex_o_tag
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 3
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 96 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 97 #############
###### JUMP TO ATTACK START ######
set start_sim "137140 ns"
run "137140 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137140 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 5
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/regfile_alu_waddr_ex_o_tag
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 4
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 97 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 98 #############
###### JUMP TO ATTACK START ######
set start_sim "137180 ns"
run "137180 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137180 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 5
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/regfile_alu_waddr_ex_o_tag
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 4
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 98 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 99 #############
###### JUMP TO ATTACK START ######
set start_sim "137220 ns"
run "137220 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137220 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 5
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/regfile_alu_waddr_ex_o_tag
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 4
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 99 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 100 #############
###### JUMP TO ATTACK START ######
set start_sim "137260 ns"
run "137260 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137260 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 5
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/regfile_alu_waddr_ex_o_tag
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 4
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 100 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 101 #############
###### JUMP TO ATTACK START ######
set start_sim "137300 ns"
run "137300 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137300 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 5
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/regfile_alu_waddr_ex_o_tag
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 4
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 101 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 102 #############
###### JUMP TO ATTACK START ######
set start_sim "137340 ns"
run "137340 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137340 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 5
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/regfile_alu_waddr_ex_o_tag
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 4
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 102 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 103 #############
###### JUMP TO ATTACK START ######
set start_sim "137140 ns"
run "137140 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137140 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 1
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/register_set_o_tag
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 0
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 103 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 104 #############
###### JUMP TO ATTACK START ######
set start_sim "137180 ns"
run "137180 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137180 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 1
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/register_set_o_tag
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 0
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 104 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 105 #############
###### JUMP TO ATTACK START ######
set start_sim "137220 ns"
run "137220 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137220 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 1
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/register_set_o_tag
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 0
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 105 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 106 #############
###### JUMP TO ATTACK START ######
set start_sim "137260 ns"
run "137260 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137260 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 1
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/register_set_o_tag
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 0
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 106 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 107 #############
###### JUMP TO ATTACK START ######
set start_sim "137300 ns"
run "137300 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137300 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 1
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/register_set_o_tag
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 0
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 107 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 108 #############
###### JUMP TO ATTACK START ######
set start_sim "137340 ns"
run "137340 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137340 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 1
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/register_set_o_tag
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 0
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 108 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 109 #############
###### JUMP TO ATTACK START ######
set start_sim "137140 ns"
run "137140 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137140 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 1
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/store_dest_addr_ex_o_tag
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 0
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 109 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 110 #############
###### JUMP TO ATTACK START ######
set start_sim "137180 ns"
run "137180 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137180 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 1
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/store_dest_addr_ex_o_tag
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 0
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 110 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 111 #############
###### JUMP TO ATTACK START ######
set start_sim "137220 ns"
run "137220 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137220 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 1
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/store_dest_addr_ex_o_tag
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 0
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 111 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 112 #############
###### JUMP TO ATTACK START ######
set start_sim "137260 ns"
run "137260 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137260 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 1
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/store_dest_addr_ex_o_tag
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 0
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 112 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 113 #############
###### JUMP TO ATTACK START ######
set start_sim "137300 ns"
run "137300 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137300 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 1
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/store_dest_addr_ex_o_tag
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 0
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 113 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 114 #############
###### JUMP TO ATTACK START ######
set start_sim "137340 ns"
run "137340 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137340 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 1
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/store_dest_addr_ex_o_tag
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 0
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 114 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 115 #############
###### JUMP TO ATTACK START ######
set start_sim "137140 ns"
run "137140 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137140 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 1
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/store_source_ex_o_tag
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 0
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 115 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 116 #############
###### JUMP TO ATTACK START ######
set start_sim "137180 ns"
run "137180 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137180 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 1
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/store_source_ex_o_tag
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 0
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 116 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 117 #############
###### JUMP TO ATTACK START ######
set start_sim "137220 ns"
run "137220 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137220 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 1
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/store_source_ex_o_tag
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 0
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 117 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 118 #############
###### JUMP TO ATTACK START ######
set start_sim "137260 ns"
run "137260 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137260 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 1
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/store_source_ex_o_tag
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 0
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 118 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 119 #############
###### JUMP TO ATTACK START ######
set start_sim "137300 ns"
run "137300 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137300 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 1
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/store_source_ex_o_tag
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 0
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 119 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 120 #############
###### JUMP TO ATTACK START ######
set start_sim "137340 ns"
run "137340 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137340 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 1
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/store_source_ex_o_tag
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 0
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 120 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 121 #############
###### JUMP TO ATTACK START ######
set start_sim "137140 ns"
run "137140 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137140 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 1
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/use_store_ops_ex_o
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 0
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 121 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 122 #############
###### JUMP TO ATTACK START ######
set start_sim "137180 ns"
run "137180 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137180 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 1
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/use_store_ops_ex_o
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 0
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 122 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 123 #############
###### JUMP TO ATTACK START ######
set start_sim "137220 ns"
run "137220 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137220 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 1
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/use_store_ops_ex_o
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 0
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 123 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 124 #############
###### JUMP TO ATTACK START ######
set start_sim "137260 ns"
run "137260 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137260 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 1
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/use_store_ops_ex_o
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 0
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 124 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 125 #############
###### JUMP TO ATTACK START ######
set start_sim "137300 ns"
run "137300 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137300 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 1
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/use_store_ops_ex_o
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 0
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 125 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 126 #############
###### JUMP TO ATTACK START ######
set start_sim "137340 ns"
run "137340 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137340 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 1
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/use_store_ops_ex_o
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 0
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 126 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 127 #############
###### JUMP TO ATTACK START ######
set start_sim "137140 ns"
run "137140 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137140 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 1
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[0\]
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 0
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 127 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 128 #############
###### JUMP TO ATTACK START ######
set start_sim "137180 ns"
run "137180 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137180 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 1
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[0\]
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 0
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 128 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 129 #############
###### JUMP TO ATTACK START ######
set start_sim "137220 ns"
run "137220 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137220 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 1
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[0\]
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 0
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 129 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 130 #############
###### JUMP TO ATTACK START ######
set start_sim "137260 ns"
run "137260 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137260 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 1
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[0\]
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 0
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 130 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 131 #############
###### JUMP TO ATTACK START ######
set start_sim "137300 ns"
run "137300 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137300 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 1
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[0\]
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 0
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 131 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 132 #############
###### JUMP TO ATTACK START ######
set start_sim "137340 ns"
run "137340 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137340 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 1
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[0\]
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 0
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 132 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 133 #############
###### JUMP TO ATTACK START ######
set start_sim "137140 ns"
run "137140 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137140 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 1
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[1\]
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 0
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 133 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 134 #############
###### JUMP TO ATTACK START ######
set start_sim "137180 ns"
run "137180 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137180 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 1
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[1\]
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 0
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 134 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 135 #############
###### JUMP TO ATTACK START ######
set start_sim "137220 ns"
run "137220 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137220 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 1
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[1\]
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 0
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 135 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 136 #############
###### JUMP TO ATTACK START ######
set start_sim "137260 ns"
run "137260 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137260 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 1
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[1\]
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 0
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 136 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 137 #############
###### JUMP TO ATTACK START ######
set start_sim "137300 ns"
run "137300 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137300 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 1
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[1\]
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 0
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 137 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 138 #############
###### JUMP TO ATTACK START ######
set start_sim "137340 ns"
run "137340 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137340 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 1
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[1\]
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 0
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 138 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 139 #############
###### JUMP TO ATTACK START ######
set start_sim "137140 ns"
run "137140 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137140 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 1
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[2\]
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 0
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 139 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 140 #############
###### JUMP TO ATTACK START ######
set start_sim "137180 ns"
run "137180 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137180 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 1
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[2\]
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 0
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 140 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 141 #############
###### JUMP TO ATTACK START ######
set start_sim "137220 ns"
run "137220 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137220 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 1
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[2\]
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 0
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 141 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 142 #############
###### JUMP TO ATTACK START ######
set start_sim "137260 ns"
run "137260 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137260 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 1
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[2\]
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 0
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 142 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 143 #############
###### JUMP TO ATTACK START ######
set start_sim "137300 ns"
run "137300 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137300 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 1
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[2\]
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 0
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 143 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 144 #############
###### JUMP TO ATTACK START ######
set start_sim "137340 ns"
run "137340 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137340 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 1
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[2\]
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 0
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 144 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 145 #############
###### JUMP TO ATTACK START ######
set start_sim "137140 ns"
run "137140 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137140 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 1
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[3\]
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 0
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 145 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 146 #############
###### JUMP TO ATTACK START ######
set start_sim "137180 ns"
run "137180 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137180 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 1
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[3\]
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 0
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 146 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 147 #############
###### JUMP TO ATTACK START ######
set start_sim "137220 ns"
run "137220 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137220 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 1
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[3\]
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 0
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 147 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 148 #############
###### JUMP TO ATTACK START ######
set start_sim "137260 ns"
run "137260 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137260 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 1
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[3\]
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 0
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 148 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 149 #############
###### JUMP TO ATTACK START ######
set start_sim "137300 ns"
run "137300 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137300 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 1
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[3\]
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 0
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 149 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 150 #############
###### JUMP TO ATTACK START ######
set start_sim "137340 ns"
run "137340 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137340 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 1
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[3\]
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 0
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 150 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 151 #############
###### JUMP TO ATTACK START ######
set start_sim "137140 ns"
run "137140 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137140 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 1
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[4\]
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 0
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 151 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 152 #############
###### JUMP TO ATTACK START ######
set start_sim "137180 ns"
run "137180 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137180 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 1
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[4\]
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 0
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 152 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 153 #############
###### JUMP TO ATTACK START ######
set start_sim "137220 ns"
run "137220 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137220 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 1
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[4\]
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 0
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 153 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 154 #############
###### JUMP TO ATTACK START ######
set start_sim "137260 ns"
run "137260 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137260 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 1
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[4\]
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 0
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 154 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 155 #############
###### JUMP TO ATTACK START ######
set start_sim "137300 ns"
run "137300 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137300 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 1
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[4\]
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 0
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 155 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 156 #############
###### JUMP TO ATTACK START ######
set start_sim "137340 ns"
run "137340 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137340 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 1
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[4\]
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 0
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 156 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 157 #############
###### JUMP TO ATTACK START ######
set start_sim "137140 ns"
run "137140 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137140 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 1
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[5\]
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 0
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 157 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 158 #############
###### JUMP TO ATTACK START ######
set start_sim "137180 ns"
run "137180 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137180 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 1
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[5\]
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 0
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 158 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 159 #############
###### JUMP TO ATTACK START ######
set start_sim "137220 ns"
run "137220 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137220 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 1
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[5\]
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 0
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 159 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 160 #############
###### JUMP TO ATTACK START ######
set start_sim "137260 ns"
run "137260 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137260 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 1
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[5\]
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 0
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 160 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 161 #############
###### JUMP TO ATTACK START ######
set start_sim "137300 ns"
run "137300 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137300 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 1
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[5\]
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 0
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 161 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 162 #############
###### JUMP TO ATTACK START ######
set start_sim "137340 ns"
run "137340 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137340 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 1
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[5\]
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 0
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 162 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 163 #############
###### JUMP TO ATTACK START ######
set start_sim "137140 ns"
run "137140 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137140 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 1
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[6\]
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 0
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 163 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 164 #############
###### JUMP TO ATTACK START ######
set start_sim "137180 ns"
run "137180 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137180 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 1
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[6\]
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 0
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 164 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 165 #############
###### JUMP TO ATTACK START ######
set start_sim "137220 ns"
run "137220 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137220 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 1
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[6\]
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 0
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 165 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 166 #############
###### JUMP TO ATTACK START ######
set start_sim "137260 ns"
run "137260 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137260 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 1
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[6\]
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 0
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 166 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 167 #############
###### JUMP TO ATTACK START ######
set start_sim "137300 ns"
run "137300 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137300 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 1
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[6\]
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 0
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 167 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 168 #############
###### JUMP TO ATTACK START ######
set start_sim "137340 ns"
run "137340 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137340 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 1
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[6\]
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 0
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 168 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 169 #############
###### JUMP TO ATTACK START ######
set start_sim "137140 ns"
run "137140 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137140 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 1
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[7\]
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 0
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 169 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 170 #############
###### JUMP TO ATTACK START ######
set start_sim "137180 ns"
run "137180 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137180 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 1
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[7\]
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 0
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 170 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 171 #############
###### JUMP TO ATTACK START ######
set start_sim "137220 ns"
run "137220 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137220 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 1
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[7\]
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 0
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 171 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 172 #############
###### JUMP TO ATTACK START ######
set start_sim "137260 ns"
run "137260 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137260 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 1
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[7\]
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 0
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 172 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 173 #############
###### JUMP TO ATTACK START ######
set start_sim "137300 ns"
run "137300 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137300 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 1
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[7\]
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 0
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 173 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 174 #############
###### JUMP TO ATTACK START ######
set start_sim "137340 ns"
run "137340 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137340 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 1
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[7\]
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 0
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 174 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 175 #############
###### JUMP TO ATTACK START ######
set start_sim "137140 ns"
run "137140 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137140 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 1
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[8\]
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 0
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 175 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 176 #############
###### JUMP TO ATTACK START ######
set start_sim "137180 ns"
run "137180 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137180 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 1
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[8\]
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 0
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 176 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 177 #############
###### JUMP TO ATTACK START ######
set start_sim "137220 ns"
run "137220 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137220 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 1
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[8\]
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 0
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 177 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 178 #############
###### JUMP TO ATTACK START ######
set start_sim "137260 ns"
run "137260 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137260 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 1
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[8\]
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 0
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 178 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 179 #############
###### JUMP TO ATTACK START ######
set start_sim "137300 ns"
run "137300 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137300 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 1
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[8\]
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 0
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 179 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 180 #############
###### JUMP TO ATTACK START ######
set start_sim "137340 ns"
run "137340 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137340 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 1
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[8\]
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 0
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 180 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 181 #############
###### JUMP TO ATTACK START ######
set start_sim "137140 ns"
run "137140 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137140 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 1
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[9\]
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 0
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 181 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 182 #############
###### JUMP TO ATTACK START ######
set start_sim "137180 ns"
run "137180 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137180 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 1
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[9\]
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 0
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 182 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 183 #############
###### JUMP TO ATTACK START ######
set start_sim "137220 ns"
run "137220 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137220 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 1
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[9\]
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 0
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 183 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 184 #############
###### JUMP TO ATTACK START ######
set start_sim "137260 ns"
run "137260 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137260 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 1
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[9\]
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 0
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 184 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 185 #############
###### JUMP TO ATTACK START ######
set start_sim "137300 ns"
run "137300 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137300 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 1
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[9\]
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 0
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 185 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 186 #############
###### JUMP TO ATTACK START ######
set start_sim "137340 ns"
run "137340 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137340 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 1
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[9\]
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 0
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 186 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 187 #############
###### JUMP TO ATTACK START ######
set start_sim "137140 ns"
run "137140 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137140 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 1
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[10\]
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 0
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 187 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 188 #############
###### JUMP TO ATTACK START ######
set start_sim "137180 ns"
run "137180 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137180 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 1
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[10\]
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 0
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 188 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 189 #############
###### JUMP TO ATTACK START ######
set start_sim "137220 ns"
run "137220 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137220 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 1
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[10\]
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 0
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 189 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 190 #############
###### JUMP TO ATTACK START ######
set start_sim "137260 ns"
run "137260 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137260 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 1
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[10\]
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 0
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 190 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 191 #############
###### JUMP TO ATTACK START ######
set start_sim "137300 ns"
run "137300 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137300 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 1
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[10\]
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 0
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 191 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 192 #############
###### JUMP TO ATTACK START ######
set start_sim "137340 ns"
run "137340 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137340 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 1
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[10\]
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 0
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 192 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 193 #############
###### JUMP TO ATTACK START ######
set start_sim "137140 ns"
run "137140 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137140 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 1
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[11\]
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 0
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 193 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 194 #############
###### JUMP TO ATTACK START ######
set start_sim "137180 ns"
run "137180 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137180 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 1
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[11\]
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 0
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 194 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 195 #############
###### JUMP TO ATTACK START ######
set start_sim "137220 ns"
run "137220 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137220 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 1
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[11\]
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 0
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 195 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 196 #############
###### JUMP TO ATTACK START ######
set start_sim "137260 ns"
run "137260 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137260 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 1
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[11\]
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 0
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 196 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 197 #############
###### JUMP TO ATTACK START ######
set start_sim "137300 ns"
run "137300 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137300 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 1
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[11\]
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 0
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 197 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 198 #############
###### JUMP TO ATTACK START ######
set start_sim "137340 ns"
run "137340 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137340 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 1
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[11\]
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 0
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 198 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 199 #############
###### JUMP TO ATTACK START ######
set start_sim "137140 ns"
run "137140 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137140 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 1
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[12\]
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 0
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 199 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 200 #############
###### JUMP TO ATTACK START ######
set start_sim "137180 ns"
run "137180 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137180 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 1
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[12\]
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 0
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 200 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 201 #############
###### JUMP TO ATTACK START ######
set start_sim "137220 ns"
run "137220 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137220 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 1
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[12\]
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 0
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 201 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 202 #############
###### JUMP TO ATTACK START ######
set start_sim "137260 ns"
run "137260 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137260 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 1
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[12\]
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 0
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 202 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 203 #############
###### JUMP TO ATTACK START ######
set start_sim "137300 ns"
run "137300 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137300 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 1
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[12\]
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 0
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 203 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 204 #############
###### JUMP TO ATTACK START ######
set start_sim "137340 ns"
run "137340 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137340 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 1
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[12\]
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 0
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 204 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 205 #############
###### JUMP TO ATTACK START ######
set start_sim "137140 ns"
run "137140 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137140 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 1
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[13\]
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 0
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 205 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 206 #############
###### JUMP TO ATTACK START ######
set start_sim "137180 ns"
run "137180 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137180 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 1
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[13\]
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 0
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 206 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 207 #############
###### JUMP TO ATTACK START ######
set start_sim "137220 ns"
run "137220 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137220 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 1
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[13\]
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 0
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 207 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 208 #############
###### JUMP TO ATTACK START ######
set start_sim "137260 ns"
run "137260 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137260 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 1
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[13\]
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 0
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 208 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 209 #############
###### JUMP TO ATTACK START ######
set start_sim "137300 ns"
run "137300 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137300 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 1
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[13\]
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 0
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 209 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 210 #############
###### JUMP TO ATTACK START ######
set start_sim "137340 ns"
run "137340 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137340 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 1
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[13\]
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 0
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 210 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 211 #############
###### JUMP TO ATTACK START ######
set start_sim "137140 ns"
run "137140 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137140 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 1
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[14\]
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 0
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 211 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 212 #############
###### JUMP TO ATTACK START ######
set start_sim "137180 ns"
run "137180 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137180 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 1
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[14\]
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 0
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 212 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 213 #############
###### JUMP TO ATTACK START ######
set start_sim "137220 ns"
run "137220 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137220 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 1
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[14\]
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 0
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 213 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 214 #############
###### JUMP TO ATTACK START ######
set start_sim "137260 ns"
run "137260 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137260 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 1
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[14\]
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 0
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 214 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 215 #############
###### JUMP TO ATTACK START ######
set start_sim "137300 ns"
run "137300 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137300 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 1
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[14\]
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 0
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 215 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 216 #############
###### JUMP TO ATTACK START ######
set start_sim "137340 ns"
run "137340 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137340 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 1
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[14\]
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 0
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 216 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 217 #############
###### JUMP TO ATTACK START ######
set start_sim "137140 ns"
run "137140 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137140 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 1
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[15\]
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 0
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 217 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 218 #############
###### JUMP TO ATTACK START ######
set start_sim "137180 ns"
run "137180 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137180 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 1
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[15\]
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 0
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 218 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 219 #############
###### JUMP TO ATTACK START ######
set start_sim "137220 ns"
run "137220 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137220 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 1
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[15\]
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 0
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 219 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 220 #############
###### JUMP TO ATTACK START ######
set start_sim "137260 ns"
run "137260 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137260 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 1
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[15\]
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 0
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 220 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 221 #############
###### JUMP TO ATTACK START ######
set start_sim "137300 ns"
run "137300 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137300 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 1
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[15\]
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 0
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 221 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 222 #############
###### JUMP TO ATTACK START ######
set start_sim "137340 ns"
run "137340 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137340 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 1
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[15\]
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 0
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 222 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 223 #############
###### JUMP TO ATTACK START ######
set start_sim "137140 ns"
run "137140 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137140 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 1
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[16\]
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 0
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 223 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 224 #############
###### JUMP TO ATTACK START ######
set start_sim "137180 ns"
run "137180 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137180 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 1
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[16\]
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 0
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 224 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 225 #############
###### JUMP TO ATTACK START ######
set start_sim "137220 ns"
run "137220 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137220 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 1
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[16\]
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 0
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 225 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 226 #############
###### JUMP TO ATTACK START ######
set start_sim "137260 ns"
run "137260 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137260 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 1
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[16\]
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 0
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 226 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 227 #############
###### JUMP TO ATTACK START ######
set start_sim "137300 ns"
run "137300 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137300 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 1
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[16\]
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 0
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 227 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 228 #############
###### JUMP TO ATTACK START ######
set start_sim "137340 ns"
run "137340 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137340 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 1
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[16\]
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 0
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 228 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 229 #############
###### JUMP TO ATTACK START ######
set start_sim "137140 ns"
run "137140 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137140 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 1
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[17\]
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 0
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 229 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 230 #############
###### JUMP TO ATTACK START ######
set start_sim "137180 ns"
run "137180 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137180 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 1
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[17\]
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 0
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 230 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 231 #############
###### JUMP TO ATTACK START ######
set start_sim "137220 ns"
run "137220 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137220 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 1
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[17\]
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 0
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 231 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 232 #############
###### JUMP TO ATTACK START ######
set start_sim "137260 ns"
run "137260 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137260 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 1
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[17\]
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 0
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 232 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 233 #############
###### JUMP TO ATTACK START ######
set start_sim "137300 ns"
run "137300 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137300 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 1
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[17\]
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 0
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 233 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 234 #############
###### JUMP TO ATTACK START ######
set start_sim "137340 ns"
run "137340 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137340 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 1
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[17\]
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 0
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 234 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 235 #############
###### JUMP TO ATTACK START ######
set start_sim "137140 ns"
run "137140 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137140 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 1
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[18\]
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 0
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 235 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 236 #############
###### JUMP TO ATTACK START ######
set start_sim "137180 ns"
run "137180 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137180 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 1
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[18\]
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 0
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 236 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 237 #############
###### JUMP TO ATTACK START ######
set start_sim "137220 ns"
run "137220 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137220 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 1
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[18\]
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 0
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 237 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 238 #############
###### JUMP TO ATTACK START ######
set start_sim "137260 ns"
run "137260 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137260 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 1
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[18\]
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 0
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 238 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 239 #############
###### JUMP TO ATTACK START ######
set start_sim "137300 ns"
run "137300 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137300 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 1
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[18\]
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 0
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 239 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 240 #############
###### JUMP TO ATTACK START ######
set start_sim "137340 ns"
run "137340 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137340 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 1
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[18\]
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 0
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 240 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 241 #############
###### JUMP TO ATTACK START ######
set start_sim "137140 ns"
run "137140 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137140 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 1
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[19\]
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 0
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 241 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 242 #############
###### JUMP TO ATTACK START ######
set start_sim "137180 ns"
run "137180 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137180 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 1
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[19\]
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 0
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 242 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 243 #############
###### JUMP TO ATTACK START ######
set start_sim "137220 ns"
run "137220 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137220 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 1
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[19\]
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 0
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 243 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 244 #############
###### JUMP TO ATTACK START ######
set start_sim "137260 ns"
run "137260 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137260 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 1
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[19\]
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 0
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 244 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 245 #############
###### JUMP TO ATTACK START ######
set start_sim "137300 ns"
run "137300 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137300 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 1
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[19\]
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 0
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 245 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 246 #############
###### JUMP TO ATTACK START ######
set start_sim "137340 ns"
run "137340 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137340 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 1
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[19\]
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 0
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 246 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 247 #############
###### JUMP TO ATTACK START ######
set start_sim "137140 ns"
run "137140 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137140 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 1
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[20\]
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 0
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 247 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 248 #############
###### JUMP TO ATTACK START ######
set start_sim "137180 ns"
run "137180 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137180 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 1
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[20\]
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 0
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 248 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 249 #############
###### JUMP TO ATTACK START ######
set start_sim "137220 ns"
run "137220 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137220 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 1
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[20\]
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 0
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 249 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 250 #############
###### JUMP TO ATTACK START ######
set start_sim "137260 ns"
run "137260 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137260 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 1
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[20\]
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 0
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 250 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 251 #############
###### JUMP TO ATTACK START ######
set start_sim "137300 ns"
run "137300 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137300 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 1
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[20\]
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 0
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 251 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 252 #############
###### JUMP TO ATTACK START ######
set start_sim "137340 ns"
run "137340 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137340 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 1
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[20\]
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 0
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 252 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 253 #############
###### JUMP TO ATTACK START ######
set start_sim "137140 ns"
run "137140 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137140 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 1
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[21\]
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 0
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 253 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 254 #############
###### JUMP TO ATTACK START ######
set start_sim "137180 ns"
run "137180 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137180 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 1
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[21\]
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 0
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 254 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 255 #############
###### JUMP TO ATTACK START ######
set start_sim "137220 ns"
run "137220 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137220 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 1
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[21\]
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 0
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 255 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 256 #############
###### JUMP TO ATTACK START ######
set start_sim "137260 ns"
run "137260 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137260 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 1
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[21\]
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 0
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 256 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 257 #############
###### JUMP TO ATTACK START ######
set start_sim "137300 ns"
run "137300 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137300 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 1
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[21\]
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 0
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 257 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 258 #############
###### JUMP TO ATTACK START ######
set start_sim "137340 ns"
run "137340 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137340 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 1
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[21\]
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 0
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 258 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 259 #############
###### JUMP TO ATTACK START ######
set start_sim "137140 ns"
run "137140 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137140 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 1
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[22\]
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 0
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 259 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 260 #############
###### JUMP TO ATTACK START ######
set start_sim "137180 ns"
run "137180 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137180 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 1
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[22\]
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 0
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 260 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 261 #############
###### JUMP TO ATTACK START ######
set start_sim "137220 ns"
run "137220 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137220 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 1
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[22\]
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 0
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 261 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 262 #############
###### JUMP TO ATTACK START ######
set start_sim "137260 ns"
run "137260 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137260 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 1
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[22\]
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 0
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 262 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 263 #############
###### JUMP TO ATTACK START ######
set start_sim "137300 ns"
run "137300 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137300 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 1
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[22\]
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 0
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 263 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 264 #############
###### JUMP TO ATTACK START ######
set start_sim "137340 ns"
run "137340 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137340 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 1
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[22\]
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 0
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 264 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 265 #############
###### JUMP TO ATTACK START ######
set start_sim "137140 ns"
run "137140 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137140 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 1
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[23\]
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 0
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 265 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 266 #############
###### JUMP TO ATTACK START ######
set start_sim "137180 ns"
run "137180 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137180 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 1
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[23\]
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 0
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 266 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 267 #############
###### JUMP TO ATTACK START ######
set start_sim "137220 ns"
run "137220 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137220 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 1
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[23\]
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 0
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 267 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 268 #############
###### JUMP TO ATTACK START ######
set start_sim "137260 ns"
run "137260 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137260 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 1
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[23\]
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 0
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 268 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 269 #############
###### JUMP TO ATTACK START ######
set start_sim "137300 ns"
run "137300 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137300 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 1
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[23\]
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 0
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 269 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 270 #############
###### JUMP TO ATTACK START ######
set start_sim "137340 ns"
run "137340 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137340 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 1
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[23\]
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 0
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 270 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 271 #############
###### JUMP TO ATTACK START ######
set start_sim "137140 ns"
run "137140 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137140 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 1
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[24\]
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 0
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 271 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 272 #############
###### JUMP TO ATTACK START ######
set start_sim "137180 ns"
run "137180 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137180 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 1
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[24\]
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 0
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 272 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 273 #############
###### JUMP TO ATTACK START ######
set start_sim "137220 ns"
run "137220 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137220 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 1
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[24\]
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 0
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 273 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 274 #############
###### JUMP TO ATTACK START ######
set start_sim "137260 ns"
run "137260 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137260 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 1
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[24\]
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 0
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 274 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 275 #############
###### JUMP TO ATTACK START ######
set start_sim "137300 ns"
run "137300 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137300 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 1
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[24\]
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 0
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 275 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 276 #############
###### JUMP TO ATTACK START ######
set start_sim "137340 ns"
run "137340 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137340 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 1
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[24\]
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 0
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 276 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 277 #############
###### JUMP TO ATTACK START ######
set start_sim "137140 ns"
run "137140 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137140 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 1
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[25\]
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 0
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 277 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 278 #############
###### JUMP TO ATTACK START ######
set start_sim "137180 ns"
run "137180 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137180 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 1
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[25\]
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 0
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 278 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 279 #############
###### JUMP TO ATTACK START ######
set start_sim "137220 ns"
run "137220 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137220 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 1
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[25\]
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 0
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 279 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 280 #############
###### JUMP TO ATTACK START ######
set start_sim "137260 ns"
run "137260 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137260 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 1
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[25\]
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 0
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 280 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 281 #############
###### JUMP TO ATTACK START ######
set start_sim "137300 ns"
run "137300 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137300 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 1
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[25\]
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 0
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 281 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 282 #############
###### JUMP TO ATTACK START ######
set start_sim "137340 ns"
run "137340 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137340 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 1
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[25\]
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 0
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 282 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 283 #############
###### JUMP TO ATTACK START ######
set start_sim "137140 ns"
run "137140 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137140 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 1
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[26\]
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 0
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 283 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 284 #############
###### JUMP TO ATTACK START ######
set start_sim "137180 ns"
run "137180 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137180 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 1
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[26\]
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 0
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 284 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 285 #############
###### JUMP TO ATTACK START ######
set start_sim "137220 ns"
run "137220 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137220 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 1
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[26\]
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 0
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 285 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 286 #############
###### JUMP TO ATTACK START ######
set start_sim "137260 ns"
run "137260 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137260 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 1
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[26\]
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 0
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 286 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 287 #############
###### JUMP TO ATTACK START ######
set start_sim "137300 ns"
run "137300 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137300 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 1
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[26\]
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 0
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 287 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 288 #############
###### JUMP TO ATTACK START ######
set start_sim "137340 ns"
run "137340 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137340 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 1
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[26\]
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 0
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 288 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 289 #############
###### JUMP TO ATTACK START ######
set start_sim "137140 ns"
run "137140 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137140 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 1
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[27\]
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 0
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 289 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 290 #############
###### JUMP TO ATTACK START ######
set start_sim "137180 ns"
run "137180 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137180 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 1
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[27\]
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 0
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 290 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 291 #############
###### JUMP TO ATTACK START ######
set start_sim "137220 ns"
run "137220 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137220 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 1
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[27\]
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 0
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 291 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 292 #############
###### JUMP TO ATTACK START ######
set start_sim "137260 ns"
run "137260 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137260 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 1
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[27\]
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 0
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 292 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 293 #############
###### JUMP TO ATTACK START ######
set start_sim "137300 ns"
run "137300 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137300 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 1
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[27\]
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 0
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 293 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 294 #############
###### JUMP TO ATTACK START ######
set start_sim "137340 ns"
run "137340 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137340 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 1
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[27\]
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 0
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 294 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 295 #############
###### JUMP TO ATTACK START ######
set start_sim "137140 ns"
run "137140 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137140 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 1
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[28\]
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 0
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 295 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 296 #############
###### JUMP TO ATTACK START ######
set start_sim "137180 ns"
run "137180 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137180 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 1
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[28\]
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 0
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 296 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 297 #############
###### JUMP TO ATTACK START ######
set start_sim "137220 ns"
run "137220 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137220 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 1
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[28\]
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 0
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 297 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 298 #############
###### JUMP TO ATTACK START ######
set start_sim "137260 ns"
run "137260 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137260 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 1
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[28\]
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 0
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 298 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 299 #############
###### JUMP TO ATTACK START ######
set start_sim "137300 ns"
run "137300 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137300 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 1
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[28\]
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 0
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 299 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 300 #############
###### JUMP TO ATTACK START ######
set start_sim "137340 ns"
run "137340 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137340 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 1
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[28\]
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 0
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 300 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 301 #############
###### JUMP TO ATTACK START ######
set start_sim "137140 ns"
run "137140 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137140 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 1
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[29\]
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 0
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 301 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 302 #############
###### JUMP TO ATTACK START ######
set start_sim "137180 ns"
run "137180 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137180 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 1
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[29\]
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 0
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 302 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 303 #############
###### JUMP TO ATTACK START ######
set start_sim "137220 ns"
run "137220 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137220 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 1
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[29\]
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 0
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 303 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 304 #############
###### JUMP TO ATTACK START ######
set start_sim "137260 ns"
run "137260 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137260 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 1
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[29\]
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 0
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 304 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 305 #############
###### JUMP TO ATTACK START ######
set start_sim "137300 ns"
run "137300 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137300 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 1
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[29\]
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 0
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 305 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 306 #############
###### JUMP TO ATTACK START ######
set start_sim "137340 ns"
run "137340 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137340 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 1
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[29\]
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 0
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 306 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 307 #############
###### JUMP TO ATTACK START ######
set start_sim "137140 ns"
run "137140 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137140 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 1
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[30\]
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 0
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 307 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 308 #############
###### JUMP TO ATTACK START ######
set start_sim "137180 ns"
run "137180 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137180 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 1
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[30\]
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 0
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 308 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 309 #############
###### JUMP TO ATTACK START ######
set start_sim "137220 ns"
run "137220 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137220 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 1
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[30\]
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 0
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 309 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 310 #############
###### JUMP TO ATTACK START ######
set start_sim "137260 ns"
run "137260 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137260 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 1
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[30\]
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 0
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 310 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 311 #############
###### JUMP TO ATTACK START ######
set start_sim "137300 ns"
run "137300 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137300 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 1
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[30\]
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 0
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 311 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 312 #############
###### JUMP TO ATTACK START ######
set start_sim "137340 ns"
run "137340 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137340 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 1
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[30\]
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 0
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 312 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 313 #############
###### JUMP TO ATTACK START ######
set start_sim "137140 ns"
run "137140 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137140 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 1
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[31\]
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 0
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 313 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 314 #############
###### JUMP TO ATTACK START ######
set start_sim "137180 ns"
run "137180 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137180 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 1
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[31\]
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 0
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 314 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 315 #############
###### JUMP TO ATTACK START ######
set start_sim "137220 ns"
run "137220 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137220 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 1
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[31\]
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 0
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 315 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 316 #############
###### JUMP TO ATTACK START ######
set start_sim "137260 ns"
run "137260 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137260 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 1
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[31\]
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 0
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 316 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 317 #############
###### JUMP TO ATTACK START ######
set start_sim "137300 ns"
run "137300 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137300 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 1
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[31\]
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 0
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 317 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 318 #############
###### JUMP TO ATTACK START ######
set start_sim "137340 ns"
run "137340 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137340 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 1
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[31\]
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 0
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 318 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 319 #############
###### JUMP TO ATTACK START ######
set start_sim "137140 ns"
run "137140 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137140 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 1
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/ex_stage_i/rs1_o_tag
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 0
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 319 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 320 #############
###### JUMP TO ATTACK START ######
set start_sim "137180 ns"
run "137180 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137180 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 1
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/ex_stage_i/rs1_o_tag
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 0
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 320 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 321 #############
###### JUMP TO ATTACK START ######
set start_sim "137220 ns"
run "137220 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137220 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 1
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/ex_stage_i/rs1_o_tag
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 0
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 321 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 322 #############
###### JUMP TO ATTACK START ######
set start_sim "137260 ns"
run "137260 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137260 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 1
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/ex_stage_i/rs1_o_tag
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 0
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 322 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 323 #############
###### JUMP TO ATTACK START ######
set start_sim "137300 ns"
run "137300 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137300 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 1
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/ex_stage_i/rs1_o_tag
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 0
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 323 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 324 #############
###### JUMP TO ATTACK START ######
set start_sim "137340 ns"
run "137340 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137340 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 1
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/ex_stage_i/rs1_o_tag
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 0
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 324 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 325 #############
###### JUMP TO ATTACK START ######
set start_sim "137140 ns"
run "137140 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137140 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 0
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 325 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 326 #############
###### JUMP TO ATTACK START ######
set start_sim "137180 ns"
run "137180 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137180 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 0
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 326 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 327 #############
###### JUMP TO ATTACK START ######
set start_sim "137220 ns"
run "137220 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137220 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 0
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 327 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 328 #############
###### JUMP TO ATTACK START ######
set start_sim "137260 ns"
run "137260 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137260 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 0
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 328 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 329 #############
###### JUMP TO ATTACK START ######
set start_sim "137300 ns"
run "137300 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137300 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 0
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 329 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 330 #############
###### JUMP TO ATTACK START ######
set start_sim "137340 ns"
run "137340 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137340 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 0
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 330 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 331 #############
###### JUMP TO ATTACK START ######
set start_sim "137140 ns"
run "137140 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137140 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 1
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 331 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 332 #############
###### JUMP TO ATTACK START ######
set start_sim "137180 ns"
run "137180 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137180 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 1
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 332 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 333 #############
###### JUMP TO ATTACK START ######
set start_sim "137220 ns"
run "137220 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137220 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 1
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 333 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 334 #############
###### JUMP TO ATTACK START ######
set start_sim "137260 ns"
run "137260 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137260 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 1
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 334 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 335 #############
###### JUMP TO ATTACK START ######
set start_sim "137300 ns"
run "137300 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137300 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 1
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 335 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 336 #############
###### JUMP TO ATTACK START ######
set start_sim "137340 ns"
run "137340 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137340 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 1
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 336 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 337 #############
###### JUMP TO ATTACK START ######
set start_sim "137140 ns"
run "137140 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137140 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 2
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 337 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 338 #############
###### JUMP TO ATTACK START ######
set start_sim "137180 ns"
run "137180 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137180 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 2
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 338 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 339 #############
###### JUMP TO ATTACK START ######
set start_sim "137220 ns"
run "137220 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137220 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 2
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 339 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 340 #############
###### JUMP TO ATTACK START ######
set start_sim "137260 ns"
run "137260 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137260 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 2
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 340 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 341 #############
###### JUMP TO ATTACK START ######
set start_sim "137300 ns"
run "137300 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137300 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 2
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 341 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 342 #############
###### JUMP TO ATTACK START ######
set start_sim "137340 ns"
run "137340 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137340 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 2
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 342 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 343 #############
###### JUMP TO ATTACK START ######
set start_sim "137140 ns"
run "137140 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137140 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 3
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 343 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 344 #############
###### JUMP TO ATTACK START ######
set start_sim "137180 ns"
run "137180 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137180 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 3
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 344 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 345 #############
###### JUMP TO ATTACK START ######
set start_sim "137220 ns"
run "137220 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137220 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 3
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 345 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 346 #############
###### JUMP TO ATTACK START ######
set start_sim "137260 ns"
run "137260 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137260 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 3
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 346 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 347 #############
###### JUMP TO ATTACK START ######
set start_sim "137300 ns"
run "137300 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137300 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 3
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 347 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 348 #############
###### JUMP TO ATTACK START ######
set start_sim "137340 ns"
run "137340 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137340 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 3
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 348 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 349 #############
###### JUMP TO ATTACK START ######
set start_sim "137140 ns"
run "137140 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137140 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 4
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 349 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 350 #############
###### JUMP TO ATTACK START ######
set start_sim "137180 ns"
run "137180 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137180 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 4
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 350 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 351 #############
###### JUMP TO ATTACK START ######
set start_sim "137220 ns"
run "137220 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137220 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 4
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 351 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 352 #############
###### JUMP TO ATTACK START ######
set start_sim "137260 ns"
run "137260 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137260 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 4
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 352 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 353 #############
###### JUMP TO ATTACK START ######
set start_sim "137300 ns"
run "137300 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137300 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 4
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 353 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 354 #############
###### JUMP TO ATTACK START ######
set start_sim "137340 ns"
run "137340 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137340 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 4
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 354 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 355 #############
###### JUMP TO ATTACK START ######
set start_sim "137140 ns"
run "137140 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137140 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 5
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 355 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 356 #############
###### JUMP TO ATTACK START ######
set start_sim "137180 ns"
run "137180 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137180 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 5
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 356 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 357 #############
###### JUMP TO ATTACK START ######
set start_sim "137220 ns"
run "137220 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137220 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 5
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 357 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 358 #############
###### JUMP TO ATTACK START ######
set start_sim "137260 ns"
run "137260 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137260 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 5
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 358 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 359 #############
###### JUMP TO ATTACK START ######
set start_sim "137300 ns"
run "137300 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137300 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 5
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 359 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 360 #############
###### JUMP TO ATTACK START ######
set start_sim "137340 ns"
run "137340 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137340 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 5
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 360 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 361 #############
###### JUMP TO ATTACK START ######
set start_sim "137140 ns"
run "137140 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137140 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 6
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 361 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 362 #############
###### JUMP TO ATTACK START ######
set start_sim "137180 ns"
run "137180 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137180 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 6
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 362 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 363 #############
###### JUMP TO ATTACK START ######
set start_sim "137220 ns"
run "137220 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137220 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 6
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 363 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 364 #############
###### JUMP TO ATTACK START ######
set start_sim "137260 ns"
run "137260 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137260 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 6
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 364 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 365 #############
###### JUMP TO ATTACK START ######
set start_sim "137300 ns"
run "137300 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137300 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 6
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 365 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 366 #############
###### JUMP TO ATTACK START ######
set start_sim "137340 ns"
run "137340 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137340 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 6
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 366 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 367 #############
###### JUMP TO ATTACK START ######
set start_sim "137140 ns"
run "137140 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137140 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 7
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 367 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 368 #############
###### JUMP TO ATTACK START ######
set start_sim "137180 ns"
run "137180 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137180 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 7
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 368 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 369 #############
###### JUMP TO ATTACK START ######
set start_sim "137220 ns"
run "137220 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137220 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 7
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 369 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 370 #############
###### JUMP TO ATTACK START ######
set start_sim "137260 ns"
run "137260 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137260 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 7
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 370 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 371 #############
###### JUMP TO ATTACK START ######
set start_sim "137300 ns"
run "137300 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137300 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 7
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 371 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 372 #############
###### JUMP TO ATTACK START ######
set start_sim "137340 ns"
run "137340 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137340 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 7
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 372 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 373 #############
###### JUMP TO ATTACK START ######
set start_sim "137140 ns"
run "137140 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137140 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 8
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 373 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 374 #############
###### JUMP TO ATTACK START ######
set start_sim "137180 ns"
run "137180 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137180 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 8
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 374 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 375 #############
###### JUMP TO ATTACK START ######
set start_sim "137220 ns"
run "137220 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137220 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 8
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 375 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 376 #############
###### JUMP TO ATTACK START ######
set start_sim "137260 ns"
run "137260 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137260 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 8
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 376 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 377 #############
###### JUMP TO ATTACK START ######
set start_sim "137300 ns"
run "137300 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137300 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 8
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 377 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 378 #############
###### JUMP TO ATTACK START ######
set start_sim "137340 ns"
run "137340 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137340 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 8
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 378 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 379 #############
###### JUMP TO ATTACK START ######
set start_sim "137140 ns"
run "137140 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137140 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 9
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 379 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 380 #############
###### JUMP TO ATTACK START ######
set start_sim "137180 ns"
run "137180 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137180 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 9
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 380 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 381 #############
###### JUMP TO ATTACK START ######
set start_sim "137220 ns"
run "137220 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137220 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 9
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 381 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 382 #############
###### JUMP TO ATTACK START ######
set start_sim "137260 ns"
run "137260 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137260 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 9
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 382 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 383 #############
###### JUMP TO ATTACK START ######
set start_sim "137300 ns"
run "137300 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137300 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 9
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 383 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 384 #############
###### JUMP TO ATTACK START ######
set start_sim "137340 ns"
run "137340 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137340 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 9
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 384 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 385 #############
###### JUMP TO ATTACK START ######
set start_sim "137140 ns"
run "137140 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137140 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 10
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 385 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 386 #############
###### JUMP TO ATTACK START ######
set start_sim "137180 ns"
run "137180 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137180 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 10
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 386 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 387 #############
###### JUMP TO ATTACK START ######
set start_sim "137220 ns"
run "137220 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137220 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 10
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 387 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 388 #############
###### JUMP TO ATTACK START ######
set start_sim "137260 ns"
run "137260 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137260 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 10
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 388 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 389 #############
###### JUMP TO ATTACK START ######
set start_sim "137300 ns"
run "137300 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137300 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 10
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 389 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 390 #############
###### JUMP TO ATTACK START ######
set start_sim "137340 ns"
run "137340 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137340 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 10
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 390 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 391 #############
###### JUMP TO ATTACK START ######
set start_sim "137140 ns"
run "137140 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137140 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 11
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 391 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 392 #############
###### JUMP TO ATTACK START ######
set start_sim "137180 ns"
run "137180 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137180 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 11
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 392 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 393 #############
###### JUMP TO ATTACK START ######
set start_sim "137220 ns"
run "137220 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137220 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 11
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 393 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 394 #############
###### JUMP TO ATTACK START ######
set start_sim "137260 ns"
run "137260 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137260 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 11
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 394 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 395 #############
###### JUMP TO ATTACK START ######
set start_sim "137300 ns"
run "137300 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137300 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 11
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 395 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 396 #############
###### JUMP TO ATTACK START ######
set start_sim "137340 ns"
run "137340 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137340 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 11
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 396 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 397 #############
###### JUMP TO ATTACK START ######
set start_sim "137140 ns"
run "137140 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137140 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 12
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 397 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 398 #############
###### JUMP TO ATTACK START ######
set start_sim "137180 ns"
run "137180 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137180 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 12
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 398 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 399 #############
###### JUMP TO ATTACK START ######
set start_sim "137220 ns"
run "137220 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137220 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 12
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 399 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 400 #############
###### JUMP TO ATTACK START ######
set start_sim "137260 ns"
run "137260 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137260 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 12
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 400 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 401 #############
###### JUMP TO ATTACK START ######
set start_sim "137300 ns"
run "137300 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137300 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 12
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 401 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 402 #############
###### JUMP TO ATTACK START ######
set start_sim "137340 ns"
run "137340 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137340 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 12
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 402 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 403 #############
###### JUMP TO ATTACK START ######
set start_sim "137140 ns"
run "137140 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137140 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 13
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 403 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 404 #############
###### JUMP TO ATTACK START ######
set start_sim "137180 ns"
run "137180 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137180 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 13
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 404 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 405 #############
###### JUMP TO ATTACK START ######
set start_sim "137220 ns"
run "137220 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137220 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 13
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 405 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 406 #############
###### JUMP TO ATTACK START ######
set start_sim "137260 ns"
run "137260 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137260 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 13
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 406 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 407 #############
###### JUMP TO ATTACK START ######
set start_sim "137300 ns"
run "137300 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137300 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 13
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 407 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 408 #############
###### JUMP TO ATTACK START ######
set start_sim "137340 ns"
run "137340 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137340 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 13
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 408 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 409 #############
###### JUMP TO ATTACK START ######
set start_sim "137140 ns"
run "137140 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137140 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 14
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 409 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 410 #############
###### JUMP TO ATTACK START ######
set start_sim "137180 ns"
run "137180 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137180 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 14
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 410 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 411 #############
###### JUMP TO ATTACK START ######
set start_sim "137220 ns"
run "137220 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137220 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 14
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 411 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 412 #############
###### JUMP TO ATTACK START ######
set start_sim "137260 ns"
run "137260 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137260 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 14
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 412 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 413 #############
###### JUMP TO ATTACK START ######
set start_sim "137300 ns"
run "137300 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137300 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 14
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 413 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 414 #############
###### JUMP TO ATTACK START ######
set start_sim "137340 ns"
run "137340 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137340 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 14
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 414 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 415 #############
###### JUMP TO ATTACK START ######
set start_sim "137140 ns"
run "137140 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137140 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 15
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 415 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 416 #############
###### JUMP TO ATTACK START ######
set start_sim "137180 ns"
run "137180 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137180 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 15
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 416 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 417 #############
###### JUMP TO ATTACK START ######
set start_sim "137220 ns"
run "137220 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137220 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 15
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 417 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 418 #############
###### JUMP TO ATTACK START ######
set start_sim "137260 ns"
run "137260 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137260 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 15
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 418 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 419 #############
###### JUMP TO ATTACK START ######
set start_sim "137300 ns"
run "137300 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137300 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 15
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 419 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 420 #############
###### JUMP TO ATTACK START ######
set start_sim "137340 ns"
run "137340 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137340 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 15
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 420 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 421 #############
###### JUMP TO ATTACK START ######
set start_sim "137140 ns"
run "137140 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137140 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 16
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 421 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 422 #############
###### JUMP TO ATTACK START ######
set start_sim "137180 ns"
run "137180 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137180 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 16
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 422 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 423 #############
###### JUMP TO ATTACK START ######
set start_sim "137220 ns"
run "137220 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137220 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 16
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 423 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 424 #############
###### JUMP TO ATTACK START ######
set start_sim "137260 ns"
run "137260 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137260 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 16
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 424 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 425 #############
###### JUMP TO ATTACK START ######
set start_sim "137300 ns"
run "137300 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137300 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 16
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 425 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 426 #############
###### JUMP TO ATTACK START ######
set start_sim "137340 ns"
run "137340 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137340 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 16
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 426 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 427 #############
###### JUMP TO ATTACK START ######
set start_sim "137140 ns"
run "137140 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137140 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 17
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 427 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 428 #############
###### JUMP TO ATTACK START ######
set start_sim "137180 ns"
run "137180 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137180 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 17
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 428 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 429 #############
###### JUMP TO ATTACK START ######
set start_sim "137220 ns"
run "137220 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137220 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 17
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 429 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 430 #############
###### JUMP TO ATTACK START ######
set start_sim "137260 ns"
run "137260 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137260 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 17
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 430 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 431 #############
###### JUMP TO ATTACK START ######
set start_sim "137300 ns"
run "137300 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137300 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 17
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 431 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 432 #############
###### JUMP TO ATTACK START ######
set start_sim "137340 ns"
run "137340 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137340 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 17
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 432 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 433 #############
###### JUMP TO ATTACK START ######
set start_sim "137140 ns"
run "137140 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137140 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 18
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 433 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 434 #############
###### JUMP TO ATTACK START ######
set start_sim "137180 ns"
run "137180 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137180 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 18
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 434 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 435 #############
###### JUMP TO ATTACK START ######
set start_sim "137220 ns"
run "137220 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137220 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 18
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 435 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 436 #############
###### JUMP TO ATTACK START ######
set start_sim "137260 ns"
run "137260 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137260 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 18
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 436 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 437 #############
###### JUMP TO ATTACK START ######
set start_sim "137300 ns"
run "137300 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137300 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 18
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 437 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 438 #############
###### JUMP TO ATTACK START ######
set start_sim "137340 ns"
run "137340 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137340 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 18
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 438 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 439 #############
###### JUMP TO ATTACK START ######
set start_sim "137140 ns"
run "137140 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137140 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 19
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 439 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 440 #############
###### JUMP TO ATTACK START ######
set start_sim "137180 ns"
run "137180 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137180 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 19
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 440 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 441 #############
###### JUMP TO ATTACK START ######
set start_sim "137220 ns"
run "137220 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137220 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 19
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 441 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 442 #############
###### JUMP TO ATTACK START ######
set start_sim "137260 ns"
run "137260 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137260 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 19
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 442 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 443 #############
###### JUMP TO ATTACK START ######
set start_sim "137300 ns"
run "137300 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137300 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 19
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 443 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 444 #############
###### JUMP TO ATTACK START ######
set start_sim "137340 ns"
run "137340 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137340 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 19
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 444 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 445 #############
###### JUMP TO ATTACK START ######
set start_sim "137140 ns"
run "137140 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137140 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 20
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 445 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 446 #############
###### JUMP TO ATTACK START ######
set start_sim "137180 ns"
run "137180 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137180 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 20
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 446 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 447 #############
###### JUMP TO ATTACK START ######
set start_sim "137220 ns"
run "137220 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137220 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 20
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 447 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 448 #############
###### JUMP TO ATTACK START ######
set start_sim "137260 ns"
run "137260 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137260 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 20
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 448 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 449 #############
###### JUMP TO ATTACK START ######
set start_sim "137300 ns"
run "137300 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137300 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 20
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 449 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 450 #############
###### JUMP TO ATTACK START ######
set start_sim "137340 ns"
run "137340 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137340 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 20
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 450 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 451 #############
###### JUMP TO ATTACK START ######
set start_sim "137140 ns"
run "137140 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137140 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 21
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 451 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 452 #############
###### JUMP TO ATTACK START ######
set start_sim "137180 ns"
run "137180 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137180 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 21
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 452 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 453 #############
###### JUMP TO ATTACK START ######
set start_sim "137220 ns"
run "137220 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137220 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 21
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 453 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 454 #############
###### JUMP TO ATTACK START ######
set start_sim "137260 ns"
run "137260 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137260 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 21
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 454 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 455 #############
###### JUMP TO ATTACK START ######
set start_sim "137300 ns"
run "137300 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137300 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 21
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 455 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 456 #############
###### JUMP TO ATTACK START ######
set start_sim "137340 ns"
run "137340 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137340 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 21
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 456 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 457 #############
###### JUMP TO ATTACK START ######
set start_sim "137140 ns"
run "137140 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137140 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 22
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 457 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 458 #############
###### JUMP TO ATTACK START ######
set start_sim "137180 ns"
run "137180 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137180 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 22
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 458 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 459 #############
###### JUMP TO ATTACK START ######
set start_sim "137220 ns"
run "137220 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137220 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 22
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 459 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 460 #############
###### JUMP TO ATTACK START ######
set start_sim "137260 ns"
run "137260 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137260 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 22
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 460 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 461 #############
###### JUMP TO ATTACK START ######
set start_sim "137300 ns"
run "137300 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137300 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 22
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 461 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 462 #############
###### JUMP TO ATTACK START ######
set start_sim "137340 ns"
run "137340 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137340 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 22
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 462 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 463 #############
###### JUMP TO ATTACK START ######
set start_sim "137140 ns"
run "137140 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137140 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 23
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 463 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 464 #############
###### JUMP TO ATTACK START ######
set start_sim "137180 ns"
run "137180 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137180 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 23
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 464 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 465 #############
###### JUMP TO ATTACK START ######
set start_sim "137220 ns"
run "137220 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137220 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 23
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 465 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 466 #############
###### JUMP TO ATTACK START ######
set start_sim "137260 ns"
run "137260 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137260 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 23
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 466 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 467 #############
###### JUMP TO ATTACK START ######
set start_sim "137300 ns"
run "137300 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137300 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 23
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 467 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 468 #############
###### JUMP TO ATTACK START ######
set start_sim "137340 ns"
run "137340 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137340 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 23
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 468 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 469 #############
###### JUMP TO ATTACK START ######
set start_sim "137140 ns"
run "137140 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137140 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 24
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 469 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 470 #############
###### JUMP TO ATTACK START ######
set start_sim "137180 ns"
run "137180 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137180 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 24
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 470 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 471 #############
###### JUMP TO ATTACK START ######
set start_sim "137220 ns"
run "137220 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137220 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 24
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 471 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 472 #############
###### JUMP TO ATTACK START ######
set start_sim "137260 ns"
run "137260 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137260 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 24
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 472 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 473 #############
###### JUMP TO ATTACK START ######
set start_sim "137300 ns"
run "137300 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137300 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 24
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 473 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 474 #############
###### JUMP TO ATTACK START ######
set start_sim "137340 ns"
run "137340 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137340 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 24
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 474 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 475 #############
###### JUMP TO ATTACK START ######
set start_sim "137140 ns"
run "137140 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137140 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 25
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 475 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 476 #############
###### JUMP TO ATTACK START ######
set start_sim "137180 ns"
run "137180 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137180 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 25
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 476 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 477 #############
###### JUMP TO ATTACK START ######
set start_sim "137220 ns"
run "137220 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137220 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 25
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 477 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 478 #############
###### JUMP TO ATTACK START ######
set start_sim "137260 ns"
run "137260 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137260 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 25
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 478 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 479 #############
###### JUMP TO ATTACK START ######
set start_sim "137300 ns"
run "137300 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137300 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 25
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 479 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 480 #############
###### JUMP TO ATTACK START ######
set start_sim "137340 ns"
run "137340 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137340 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 25
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 480 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 481 #############
###### JUMP TO ATTACK START ######
set start_sim "137140 ns"
run "137140 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137140 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 26
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 481 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 482 #############
###### JUMP TO ATTACK START ######
set start_sim "137180 ns"
run "137180 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137180 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 26
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 482 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 483 #############
###### JUMP TO ATTACK START ######
set start_sim "137220 ns"
run "137220 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137220 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 26
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 483 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 484 #############
###### JUMP TO ATTACK START ######
set start_sim "137260 ns"
run "137260 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137260 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 26
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 484 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 485 #############
###### JUMP TO ATTACK START ######
set start_sim "137300 ns"
run "137300 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137300 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 26
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 485 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 486 #############
###### JUMP TO ATTACK START ######
set start_sim "137340 ns"
run "137340 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137340 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 26
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 486 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 487 #############
###### JUMP TO ATTACK START ######
set start_sim "137140 ns"
run "137140 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137140 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 27
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 487 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 488 #############
###### JUMP TO ATTACK START ######
set start_sim "137180 ns"
run "137180 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137180 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 27
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 488 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 489 #############
###### JUMP TO ATTACK START ######
set start_sim "137220 ns"
run "137220 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137220 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 27
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 489 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 490 #############
###### JUMP TO ATTACK START ######
set start_sim "137260 ns"
run "137260 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137260 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 27
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 490 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 491 #############
###### JUMP TO ATTACK START ######
set start_sim "137300 ns"
run "137300 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137300 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 27
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 491 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 492 #############
###### JUMP TO ATTACK START ######
set start_sim "137340 ns"
run "137340 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137340 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 27
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 492 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 493 #############
###### JUMP TO ATTACK START ######
set start_sim "137140 ns"
run "137140 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137140 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 28
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 493 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 494 #############
###### JUMP TO ATTACK START ######
set start_sim "137180 ns"
run "137180 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137180 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 28
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 494 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 495 #############
###### JUMP TO ATTACK START ######
set start_sim "137220 ns"
run "137220 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137220 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 28
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 495 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 496 #############
###### JUMP TO ATTACK START ######
set start_sim "137260 ns"
run "137260 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137260 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 28
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 496 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 497 #############
###### JUMP TO ATTACK START ######
set start_sim "137300 ns"
run "137300 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137300 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 28
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 497 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 498 #############
###### JUMP TO ATTACK START ######
set start_sim "137340 ns"
run "137340 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137340 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 28
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 498 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 499 #############
###### JUMP TO ATTACK START ######
set start_sim "137140 ns"
run "137140 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137140 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 29
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 499 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 500 #############
###### JUMP TO ATTACK START ######
set start_sim "137180 ns"
run "137180 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137180 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 29
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 500 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 501 #############
###### JUMP TO ATTACK START ######
set start_sim "137220 ns"
run "137220 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137220 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 29
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 501 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 502 #############
###### JUMP TO ATTACK START ######
set start_sim "137260 ns"
run "137260 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137260 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 29
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 502 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 503 #############
###### JUMP TO ATTACK START ######
set start_sim "137300 ns"
run "137300 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137300 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 29
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 503 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 504 #############
###### JUMP TO ATTACK START ######
set start_sim "137340 ns"
run "137340 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137340 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 29
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 504 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 505 #############
###### JUMP TO ATTACK START ######
set start_sim "137140 ns"
run "137140 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137140 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 30
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 505 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 506 #############
###### JUMP TO ATTACK START ######
set start_sim "137180 ns"
run "137180 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137180 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 30
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 506 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 507 #############
###### JUMP TO ATTACK START ######
set start_sim "137220 ns"
run "137220 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137220 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 30
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 507 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 508 #############
###### JUMP TO ATTACK START ######
set start_sim "137260 ns"
run "137260 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137260 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 30
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 508 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 509 #############
###### JUMP TO ATTACK START ######
set start_sim "137300 ns"
run "137300 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137300 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 30
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 509 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 510 #############
###### JUMP TO ATTACK START ######
set start_sim "137340 ns"
run "137340 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137340 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 30
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 510 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 511 #############
###### JUMP TO ATTACK START ######
set start_sim "137140 ns"
run "137140 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137140 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 31
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 511 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 512 #############
###### JUMP TO ATTACK START ######
set start_sim "137180 ns"
run "137180 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137180 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 31
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 512 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 513 #############
###### JUMP TO ATTACK START ######
set start_sim "137220 ns"
run "137220 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137220 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 31
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 513 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 514 #############
###### JUMP TO ATTACK START ######
set start_sim "137260 ns"
run "137260 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137260 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 31
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 514 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 515 #############
###### JUMP TO ATTACK START ######
set start_sim "137300 ns"
run "137300 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137300 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 31
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 515 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 516 #############
###### JUMP TO ATTACK START ######
set start_sim "137340 ns"
run "137340 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137340 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 31
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 516 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 517 #############
###### JUMP TO ATTACK START ######
set start_sim "137140 ns"
run "137140 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137140 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 0
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 517 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 518 #############
###### JUMP TO ATTACK START ######
set start_sim "137180 ns"
run "137180 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137180 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 0
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 518 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 519 #############
###### JUMP TO ATTACK START ######
set start_sim "137220 ns"
run "137220 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137220 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 0
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 519 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 520 #############
###### JUMP TO ATTACK START ######
set start_sim "137260 ns"
run "137260 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137260 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 0
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 520 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 521 #############
###### JUMP TO ATTACK START ######
set start_sim "137300 ns"
run "137300 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137300 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 0
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 521 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 522 #############
###### JUMP TO ATTACK START ######
set start_sim "137340 ns"
run "137340 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137340 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 0
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 522 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 523 #############
###### JUMP TO ATTACK START ######
set start_sim "137140 ns"
run "137140 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137140 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 1
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 523 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 524 #############
###### JUMP TO ATTACK START ######
set start_sim "137180 ns"
run "137180 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137180 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 1
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 524 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 525 #############
###### JUMP TO ATTACK START ######
set start_sim "137220 ns"
run "137220 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137220 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 1
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 525 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 526 #############
###### JUMP TO ATTACK START ######
set start_sim "137260 ns"
run "137260 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137260 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 1
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 526 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 527 #############
###### JUMP TO ATTACK START ######
set start_sim "137300 ns"
run "137300 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137300 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 1
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 527 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 528 #############
###### JUMP TO ATTACK START ######
set start_sim "137340 ns"
run "137340 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137340 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 1
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 528 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 529 #############
###### JUMP TO ATTACK START ######
set start_sim "137140 ns"
run "137140 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137140 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 2
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 529 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 530 #############
###### JUMP TO ATTACK START ######
set start_sim "137180 ns"
run "137180 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137180 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 2
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 530 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 531 #############
###### JUMP TO ATTACK START ######
set start_sim "137220 ns"
run "137220 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137220 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 2
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 531 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 532 #############
###### JUMP TO ATTACK START ######
set start_sim "137260 ns"
run "137260 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137260 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 2
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 532 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 533 #############
###### JUMP TO ATTACK START ######
set start_sim "137300 ns"
run "137300 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137300 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 2
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 533 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 534 #############
###### JUMP TO ATTACK START ######
set start_sim "137340 ns"
run "137340 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137340 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 2
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 534 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 535 #############
###### JUMP TO ATTACK START ######
set start_sim "137140 ns"
run "137140 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137140 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 3
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 535 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 536 #############
###### JUMP TO ATTACK START ######
set start_sim "137180 ns"
run "137180 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137180 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 3
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 536 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 537 #############
###### JUMP TO ATTACK START ######
set start_sim "137220 ns"
run "137220 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137220 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 3
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 537 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 538 #############
###### JUMP TO ATTACK START ######
set start_sim "137260 ns"
run "137260 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137260 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 3
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 538 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 539 #############
###### JUMP TO ATTACK START ######
set start_sim "137300 ns"
run "137300 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137300 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 3
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 539 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 540 #############
###### JUMP TO ATTACK START ######
set start_sim "137340 ns"
run "137340 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137340 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 3
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 540 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 541 #############
###### JUMP TO ATTACK START ######
set start_sim "137140 ns"
run "137140 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137140 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 4
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 541 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 542 #############
###### JUMP TO ATTACK START ######
set start_sim "137180 ns"
run "137180 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137180 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 4
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 542 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 543 #############
###### JUMP TO ATTACK START ######
set start_sim "137220 ns"
run "137220 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137220 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 4
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 543 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 544 #############
###### JUMP TO ATTACK START ######
set start_sim "137260 ns"
run "137260 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137260 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 4
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 544 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 545 #############
###### JUMP TO ATTACK START ######
set start_sim "137300 ns"
run "137300 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137300 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 4
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 545 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 546 #############
###### JUMP TO ATTACK START ######
set start_sim "137340 ns"
run "137340 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137340 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 4
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 546 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 547 #############
###### JUMP TO ATTACK START ######
set start_sim "137140 ns"
run "137140 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137140 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 5
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 547 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 548 #############
###### JUMP TO ATTACK START ######
set start_sim "137180 ns"
run "137180 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137180 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 5
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 548 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 549 #############
###### JUMP TO ATTACK START ######
set start_sim "137220 ns"
run "137220 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137220 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 5
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 549 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 550 #############
###### JUMP TO ATTACK START ######
set start_sim "137260 ns"
run "137260 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137260 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 5
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 550 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 551 #############
###### JUMP TO ATTACK START ######
set start_sim "137300 ns"
run "137300 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137300 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 5
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 551 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 552 #############
###### JUMP TO ATTACK START ######
set start_sim "137340 ns"
run "137340 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137340 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 5
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 552 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 553 #############
###### JUMP TO ATTACK START ######
set start_sim "137140 ns"
run "137140 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137140 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 6
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 553 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 554 #############
###### JUMP TO ATTACK START ######
set start_sim "137180 ns"
run "137180 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137180 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 6
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 554 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 555 #############
###### JUMP TO ATTACK START ######
set start_sim "137220 ns"
run "137220 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137220 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 6
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 555 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 556 #############
###### JUMP TO ATTACK START ######
set start_sim "137260 ns"
run "137260 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137260 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 6
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 556 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 557 #############
###### JUMP TO ATTACK START ######
set start_sim "137300 ns"
run "137300 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137300 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 6
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 557 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 558 #############
###### JUMP TO ATTACK START ######
set start_sim "137340 ns"
run "137340 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137340 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 6
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 558 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 559 #############
###### JUMP TO ATTACK START ######
set start_sim "137140 ns"
run "137140 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137140 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 7
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 559 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 560 #############
###### JUMP TO ATTACK START ######
set start_sim "137180 ns"
run "137180 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137180 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 7
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 560 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 561 #############
###### JUMP TO ATTACK START ######
set start_sim "137220 ns"
run "137220 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137220 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 7
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 561 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 562 #############
###### JUMP TO ATTACK START ######
set start_sim "137260 ns"
run "137260 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137260 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 7
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 562 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 563 #############
###### JUMP TO ATTACK START ######
set start_sim "137300 ns"
run "137300 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137300 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 7
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 563 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 564 #############
###### JUMP TO ATTACK START ######
set start_sim "137340 ns"
run "137340 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137340 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 7
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 564 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 565 #############
###### JUMP TO ATTACK START ######
set start_sim "137140 ns"
run "137140 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137140 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 8
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 565 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 566 #############
###### JUMP TO ATTACK START ######
set start_sim "137180 ns"
run "137180 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137180 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 8
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 566 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 567 #############
###### JUMP TO ATTACK START ######
set start_sim "137220 ns"
run "137220 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137220 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 8
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 567 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 568 #############
###### JUMP TO ATTACK START ######
set start_sim "137260 ns"
run "137260 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137260 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 8
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 568 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 569 #############
###### JUMP TO ATTACK START ######
set start_sim "137300 ns"
run "137300 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137300 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 8
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 569 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 570 #############
###### JUMP TO ATTACK START ######
set start_sim "137340 ns"
run "137340 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137340 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 8
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 570 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 571 #############
###### JUMP TO ATTACK START ######
set start_sim "137140 ns"
run "137140 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137140 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 9
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 571 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 572 #############
###### JUMP TO ATTACK START ######
set start_sim "137180 ns"
run "137180 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137180 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 9
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 572 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 573 #############
###### JUMP TO ATTACK START ######
set start_sim "137220 ns"
run "137220 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137220 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 9
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 573 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 574 #############
###### JUMP TO ATTACK START ######
set start_sim "137260 ns"
run "137260 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137260 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 9
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 574 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 575 #############
###### JUMP TO ATTACK START ######
set start_sim "137300 ns"
run "137300 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137300 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 9
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 575 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 576 #############
###### JUMP TO ATTACK START ######
set start_sim "137340 ns"
run "137340 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137340 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 9
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 576 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 577 #############
###### JUMP TO ATTACK START ######
set start_sim "137140 ns"
run "137140 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137140 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 10
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 577 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 578 #############
###### JUMP TO ATTACK START ######
set start_sim "137180 ns"
run "137180 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137180 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 10
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 578 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 579 #############
###### JUMP TO ATTACK START ######
set start_sim "137220 ns"
run "137220 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137220 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 10
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 579 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 580 #############
###### JUMP TO ATTACK START ######
set start_sim "137260 ns"
run "137260 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137260 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 10
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 580 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 581 #############
###### JUMP TO ATTACK START ######
set start_sim "137300 ns"
run "137300 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137300 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 10
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 581 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 582 #############
###### JUMP TO ATTACK START ######
set start_sim "137340 ns"
run "137340 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137340 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 10
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 582 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 583 #############
###### JUMP TO ATTACK START ######
set start_sim "137140 ns"
run "137140 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137140 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 11
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 583 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 584 #############
###### JUMP TO ATTACK START ######
set start_sim "137180 ns"
run "137180 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137180 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 11
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 584 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 585 #############
###### JUMP TO ATTACK START ######
set start_sim "137220 ns"
run "137220 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137220 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 11
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 585 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 586 #############
###### JUMP TO ATTACK START ######
set start_sim "137260 ns"
run "137260 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137260 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 11
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 586 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 587 #############
###### JUMP TO ATTACK START ######
set start_sim "137300 ns"
run "137300 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137300 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 11
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 587 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 588 #############
###### JUMP TO ATTACK START ######
set start_sim "137340 ns"
run "137340 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137340 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 11
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 588 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 589 #############
###### JUMP TO ATTACK START ######
set start_sim "137140 ns"
run "137140 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137140 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 12
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 589 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 590 #############
###### JUMP TO ATTACK START ######
set start_sim "137180 ns"
run "137180 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137180 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 12
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 590 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 591 #############
###### JUMP TO ATTACK START ######
set start_sim "137220 ns"
run "137220 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137220 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 12
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 591 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 592 #############
###### JUMP TO ATTACK START ######
set start_sim "137260 ns"
run "137260 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137260 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 12
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 592 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 593 #############
###### JUMP TO ATTACK START ######
set start_sim "137300 ns"
run "137300 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137300 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 12
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 593 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 594 #############
###### JUMP TO ATTACK START ######
set start_sim "137340 ns"
run "137340 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137340 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 12
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 594 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 595 #############
###### JUMP TO ATTACK START ######
set start_sim "137140 ns"
run "137140 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137140 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 13
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 595 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 596 #############
###### JUMP TO ATTACK START ######
set start_sim "137180 ns"
run "137180 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137180 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 13
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 596 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 597 #############
###### JUMP TO ATTACK START ######
set start_sim "137220 ns"
run "137220 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137220 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 13
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 597 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 598 #############
###### JUMP TO ATTACK START ######
set start_sim "137260 ns"
run "137260 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137260 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 13
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 598 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 599 #############
###### JUMP TO ATTACK START ######
set start_sim "137300 ns"
run "137300 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137300 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 13
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 599 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 600 #############
###### JUMP TO ATTACK START ######
set start_sim "137340 ns"
run "137340 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137340 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 13
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 600 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 601 #############
###### JUMP TO ATTACK START ######
set start_sim "137140 ns"
run "137140 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137140 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 14
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 601 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 602 #############
###### JUMP TO ATTACK START ######
set start_sim "137180 ns"
run "137180 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137180 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 14
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 602 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 603 #############
###### JUMP TO ATTACK START ######
set start_sim "137220 ns"
run "137220 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137220 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 14
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 603 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 604 #############
###### JUMP TO ATTACK START ######
set start_sim "137260 ns"
run "137260 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137260 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 14
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 604 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 605 #############
###### JUMP TO ATTACK START ######
set start_sim "137300 ns"
run "137300 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137300 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 14
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 605 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 606 #############
###### JUMP TO ATTACK START ######
set start_sim "137340 ns"
run "137340 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137340 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 14
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 606 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 607 #############
###### JUMP TO ATTACK START ######
set start_sim "137140 ns"
run "137140 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137140 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 15
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 607 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 608 #############
###### JUMP TO ATTACK START ######
set start_sim "137180 ns"
run "137180 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137180 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 15
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 608 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 609 #############
###### JUMP TO ATTACK START ######
set start_sim "137220 ns"
run "137220 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137220 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 15
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 609 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 610 #############
###### JUMP TO ATTACK START ######
set start_sim "137260 ns"
run "137260 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137260 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 15
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 610 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 611 #############
###### JUMP TO ATTACK START ######
set start_sim "137300 ns"
run "137300 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137300 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 15
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 611 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 612 #############
###### JUMP TO ATTACK START ######
set start_sim "137340 ns"
run "137340 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137340 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 15
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 612 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 613 #############
###### JUMP TO ATTACK START ######
set start_sim "137140 ns"
run "137140 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137140 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 16
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 613 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 614 #############
###### JUMP TO ATTACK START ######
set start_sim "137180 ns"
run "137180 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137180 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 16
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 614 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 615 #############
###### JUMP TO ATTACK START ######
set start_sim "137220 ns"
run "137220 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137220 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 16
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 615 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 616 #############
###### JUMP TO ATTACK START ######
set start_sim "137260 ns"
run "137260 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137260 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 16
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 616 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 617 #############
###### JUMP TO ATTACK START ######
set start_sim "137300 ns"
run "137300 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137300 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 16
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 617 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 618 #############
###### JUMP TO ATTACK START ######
set start_sim "137340 ns"
run "137340 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137340 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 16
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 618 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 619 #############
###### JUMP TO ATTACK START ######
set start_sim "137140 ns"
run "137140 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137140 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 17
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 619 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 620 #############
###### JUMP TO ATTACK START ######
set start_sim "137180 ns"
run "137180 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137180 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 17
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 620 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 621 #############
###### JUMP TO ATTACK START ######
set start_sim "137220 ns"
run "137220 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137220 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 17
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 621 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 622 #############
###### JUMP TO ATTACK START ######
set start_sim "137260 ns"
run "137260 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137260 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 17
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 622 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 623 #############
###### JUMP TO ATTACK START ######
set start_sim "137300 ns"
run "137300 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137300 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 17
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 623 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 624 #############
###### JUMP TO ATTACK START ######
set start_sim "137340 ns"
run "137340 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137340 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 17
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 624 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 625 #############
###### JUMP TO ATTACK START ######
set start_sim "137140 ns"
run "137140 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137140 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 18
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 625 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 626 #############
###### JUMP TO ATTACK START ######
set start_sim "137180 ns"
run "137180 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137180 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 18
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 626 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 627 #############
###### JUMP TO ATTACK START ######
set start_sim "137220 ns"
run "137220 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137220 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 18
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 627 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 628 #############
###### JUMP TO ATTACK START ######
set start_sim "137260 ns"
run "137260 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137260 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 18
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 628 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 629 #############
###### JUMP TO ATTACK START ######
set start_sim "137300 ns"
run "137300 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137300 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 18
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 629 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 630 #############
###### JUMP TO ATTACK START ######
set start_sim "137340 ns"
run "137340 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137340 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 18
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 630 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 631 #############
###### JUMP TO ATTACK START ######
set start_sim "137140 ns"
run "137140 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137140 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 19
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 631 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 632 #############
###### JUMP TO ATTACK START ######
set start_sim "137180 ns"
run "137180 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137180 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 19
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 632 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 633 #############
###### JUMP TO ATTACK START ######
set start_sim "137220 ns"
run "137220 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137220 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 19
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 633 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 634 #############
###### JUMP TO ATTACK START ######
set start_sim "137260 ns"
run "137260 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137260 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 19
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 634 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 635 #############
###### JUMP TO ATTACK START ######
set start_sim "137300 ns"
run "137300 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137300 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 19
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 635 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 636 #############
###### JUMP TO ATTACK START ######
set start_sim "137340 ns"
run "137340 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137340 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 19
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 636 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 637 #############
###### JUMP TO ATTACK START ######
set start_sim "137140 ns"
run "137140 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137140 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 20
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 637 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 638 #############
###### JUMP TO ATTACK START ######
set start_sim "137180 ns"
run "137180 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137180 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 20
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 638 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 639 #############
###### JUMP TO ATTACK START ######
set start_sim "137220 ns"
run "137220 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137220 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 20
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 639 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 640 #############
###### JUMP TO ATTACK START ######
set start_sim "137260 ns"
run "137260 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137260 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 20
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 640 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 641 #############
###### JUMP TO ATTACK START ######
set start_sim "137300 ns"
run "137300 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137300 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 20
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 641 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 642 #############
###### JUMP TO ATTACK START ######
set start_sim "137340 ns"
run "137340 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137340 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 20
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 642 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 643 #############
###### JUMP TO ATTACK START ######
set start_sim "137140 ns"
run "137140 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137140 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 21
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 643 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 644 #############
###### JUMP TO ATTACK START ######
set start_sim "137180 ns"
run "137180 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137180 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 21
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 644 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 645 #############
###### JUMP TO ATTACK START ######
set start_sim "137220 ns"
run "137220 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137220 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 21
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 645 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 646 #############
###### JUMP TO ATTACK START ######
set start_sim "137260 ns"
run "137260 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137260 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 21
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 646 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 647 #############
###### JUMP TO ATTACK START ######
set start_sim "137300 ns"
run "137300 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137300 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 21
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 647 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 648 #############
###### JUMP TO ATTACK START ######
set start_sim "137340 ns"
run "137340 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137340 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 21
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 648 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 649 #############
###### JUMP TO ATTACK START ######
set start_sim "137140 ns"
run "137140 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137140 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 22
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 649 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 650 #############
###### JUMP TO ATTACK START ######
set start_sim "137180 ns"
run "137180 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137180 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 22
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 650 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 651 #############
###### JUMP TO ATTACK START ######
set start_sim "137220 ns"
run "137220 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137220 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 22
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 651 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 652 #############
###### JUMP TO ATTACK START ######
set start_sim "137260 ns"
run "137260 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137260 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 22
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 652 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 653 #############
###### JUMP TO ATTACK START ######
set start_sim "137300 ns"
run "137300 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137300 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 22
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 653 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 654 #############
###### JUMP TO ATTACK START ######
set start_sim "137340 ns"
run "137340 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137340 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 22
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 654 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 655 #############
###### JUMP TO ATTACK START ######
set start_sim "137140 ns"
run "137140 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137140 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 23
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 655 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 656 #############
###### JUMP TO ATTACK START ######
set start_sim "137180 ns"
run "137180 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137180 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 23
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 656 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 657 #############
###### JUMP TO ATTACK START ######
set start_sim "137220 ns"
run "137220 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137220 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 23
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 657 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 658 #############
###### JUMP TO ATTACK START ######
set start_sim "137260 ns"
run "137260 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137260 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 23
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 658 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 659 #############
###### JUMP TO ATTACK START ######
set start_sim "137300 ns"
run "137300 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137300 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 23
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 659 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 660 #############
###### JUMP TO ATTACK START ######
set start_sim "137340 ns"
run "137340 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137340 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 23
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 660 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 661 #############
###### JUMP TO ATTACK START ######
set start_sim "137140 ns"
run "137140 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137140 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 24
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 661 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 662 #############
###### JUMP TO ATTACK START ######
set start_sim "137180 ns"
run "137180 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137180 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 24
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 662 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 663 #############
###### JUMP TO ATTACK START ######
set start_sim "137220 ns"
run "137220 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137220 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 24
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 663 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 664 #############
###### JUMP TO ATTACK START ######
set start_sim "137260 ns"
run "137260 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137260 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 24
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 664 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 665 #############
###### JUMP TO ATTACK START ######
set start_sim "137300 ns"
run "137300 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137300 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 24
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 665 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 666 #############
###### JUMP TO ATTACK START ######
set start_sim "137340 ns"
run "137340 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137340 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 24
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 666 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 667 #############
###### JUMP TO ATTACK START ######
set start_sim "137140 ns"
run "137140 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137140 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 25
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 667 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 668 #############
###### JUMP TO ATTACK START ######
set start_sim "137180 ns"
run "137180 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137180 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 25
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 668 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 669 #############
###### JUMP TO ATTACK START ######
set start_sim "137220 ns"
run "137220 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137220 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 25
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 669 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 670 #############
###### JUMP TO ATTACK START ######
set start_sim "137260 ns"
run "137260 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137260 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 25
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 670 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 671 #############
###### JUMP TO ATTACK START ######
set start_sim "137300 ns"
run "137300 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137300 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 25
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 671 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 672 #############
###### JUMP TO ATTACK START ######
set start_sim "137340 ns"
run "137340 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137340 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 25
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 672 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 673 #############
###### JUMP TO ATTACK START ######
set start_sim "137140 ns"
run "137140 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137140 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 26
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 673 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 674 #############
###### JUMP TO ATTACK START ######
set start_sim "137180 ns"
run "137180 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137180 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 26
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 674 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 675 #############
###### JUMP TO ATTACK START ######
set start_sim "137220 ns"
run "137220 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137220 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 26
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 675 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 676 #############
###### JUMP TO ATTACK START ######
set start_sim "137260 ns"
run "137260 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137260 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 26
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 676 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 677 #############
###### JUMP TO ATTACK START ######
set start_sim "137300 ns"
run "137300 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137300 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 26
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 677 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 678 #############
###### JUMP TO ATTACK START ######
set start_sim "137340 ns"
run "137340 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137340 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 26
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 678 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 679 #############
###### JUMP TO ATTACK START ######
set start_sim "137140 ns"
run "137140 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137140 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 27
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 679 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 680 #############
###### JUMP TO ATTACK START ######
set start_sim "137180 ns"
run "137180 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137180 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 27
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 680 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 681 #############
###### JUMP TO ATTACK START ######
set start_sim "137220 ns"
run "137220 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137220 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 27
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 681 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 682 #############
###### JUMP TO ATTACK START ######
set start_sim "137260 ns"
run "137260 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137260 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 27
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 682 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 683 #############
###### JUMP TO ATTACK START ######
set start_sim "137300 ns"
run "137300 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137300 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 27
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 683 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 684 #############
###### JUMP TO ATTACK START ######
set start_sim "137340 ns"
run "137340 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137340 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 27
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 684 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 685 #############
###### JUMP TO ATTACK START ######
set start_sim "137140 ns"
run "137140 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137140 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 28
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 685 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 686 #############
###### JUMP TO ATTACK START ######
set start_sim "137180 ns"
run "137180 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137180 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 28
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 686 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 687 #############
###### JUMP TO ATTACK START ######
set start_sim "137220 ns"
run "137220 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137220 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 28
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 687 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 688 #############
###### JUMP TO ATTACK START ######
set start_sim "137260 ns"
run "137260 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137260 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 28
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 688 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 689 #############
###### JUMP TO ATTACK START ######
set start_sim "137300 ns"
run "137300 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137300 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 28
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 689 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 690 #############
###### JUMP TO ATTACK START ######
set start_sim "137340 ns"
run "137340 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137340 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 28
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 690 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 691 #############
###### JUMP TO ATTACK START ######
set start_sim "137140 ns"
run "137140 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137140 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 29
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 691 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 692 #############
###### JUMP TO ATTACK START ######
set start_sim "137180 ns"
run "137180 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137180 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 29
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 692 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 693 #############
###### JUMP TO ATTACK START ######
set start_sim "137220 ns"
run "137220 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137220 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 29
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 693 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 694 #############
###### JUMP TO ATTACK START ######
set start_sim "137260 ns"
run "137260 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137260 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 29
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 694 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 695 #############
###### JUMP TO ATTACK START ######
set start_sim "137300 ns"
run "137300 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137300 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 29
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 695 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 696 #############
###### JUMP TO ATTACK START ######
set start_sim "137340 ns"
run "137340 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137340 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 29
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 696 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 697 #############
###### JUMP TO ATTACK START ######
set start_sim "137140 ns"
run "137140 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137140 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 30
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 697 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 698 #############
###### JUMP TO ATTACK START ######
set start_sim "137180 ns"
run "137180 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137180 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 30
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 698 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 699 #############
###### JUMP TO ATTACK START ######
set start_sim "137220 ns"
run "137220 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137220 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 30
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 699 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 700 #############
###### JUMP TO ATTACK START ######
set start_sim "137260 ns"
run "137260 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137260 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 30
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 700 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 701 #############
###### JUMP TO ATTACK START ######
set start_sim "137300 ns"
run "137300 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137300 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 30
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 701 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 702 #############
###### JUMP TO ATTACK START ######
set start_sim "137340 ns"
run "137340 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137340 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 30
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 702 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 703 #############
###### JUMP TO ATTACK START ######
set start_sim "137140 ns"
run "137140 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137140 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 31
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 703 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 704 #############
###### JUMP TO ATTACK START ######
set start_sim "137180 ns"
run "137180 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137180 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 31
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 704 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 705 #############
###### JUMP TO ATTACK START ######
set start_sim "137220 ns"
run "137220 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137220 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 31
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 705 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 706 #############
###### JUMP TO ATTACK START ######
set start_sim "137260 ns"
run "137260 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137260 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 31
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 706 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 707 #############
###### JUMP TO ATTACK START ######
set start_sim "137300 ns"
run "137300 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137300 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 31
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 707 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 708 #############
###### JUMP TO ATTACK START ######
set start_sim "137340 ns"
run "137340 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137340 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 32
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 31
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 708 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 709 #############
###### JUMP TO ATTACK START ######
set start_sim "137140 ns"
run "137140 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137140 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 2
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/load_store_unit_i/data_type_q_tag
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 0
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 709 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 710 #############
###### JUMP TO ATTACK START ######
set start_sim "137180 ns"
run "137180 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137180 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 2
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/load_store_unit_i/data_type_q_tag
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 0
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 710 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 711 #############
###### JUMP TO ATTACK START ######
set start_sim "137220 ns"
run "137220 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137220 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 2
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/load_store_unit_i/data_type_q_tag
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 0
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 711 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 712 #############
###### JUMP TO ATTACK START ######
set start_sim "137260 ns"
run "137260 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137260 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 2
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/load_store_unit_i/data_type_q_tag
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 0
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 712 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 713 #############
###### JUMP TO ATTACK START ######
set start_sim "137300 ns"
run "137300 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137300 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 2
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/load_store_unit_i/data_type_q_tag
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 0
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 713 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 714 #############
###### JUMP TO ATTACK START ######
set start_sim "137340 ns"
run "137340 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137340 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 2
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/load_store_unit_i/data_type_q_tag
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 0
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 714 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 715 #############
###### JUMP TO ATTACK START ######
set start_sim "137140 ns"
run "137140 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137140 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 2
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/load_store_unit_i/data_type_q_tag
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 1
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 715 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 716 #############
###### JUMP TO ATTACK START ######
set start_sim "137180 ns"
run "137180 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137180 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 2
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/load_store_unit_i/data_type_q_tag
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 1
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 716 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 717 #############
###### JUMP TO ATTACK START ######
set start_sim "137220 ns"
run "137220 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137220 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 2
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/load_store_unit_i/data_type_q_tag
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 1
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 717 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 718 #############
###### JUMP TO ATTACK START ######
set start_sim "137260 ns"
run "137260 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137260 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 2
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/load_store_unit_i/data_type_q_tag
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 1
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 718 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 719 #############
###### JUMP TO ATTACK START ######
set start_sim "137300 ns"
run "137300 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137300 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 2
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/load_store_unit_i/data_type_q_tag
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 1
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 719 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 720 #############
###### JUMP TO ATTACK START ######
set start_sim "137340 ns"
run "137340 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137340 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 2
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/load_store_unit_i/data_type_q_tag
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 1
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 720 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 721 #############
###### JUMP TO ATTACK START ######
set start_sim "137140 ns"
run "137140 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137140 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 1
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/load_store_unit_i/data_we_q_tag
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 0
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 721 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 722 #############
###### JUMP TO ATTACK START ######
set start_sim "137180 ns"
run "137180 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137180 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 1
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/load_store_unit_i/data_we_q_tag
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 0
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 722 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 723 #############
###### JUMP TO ATTACK START ######
set start_sim "137220 ns"
run "137220 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137220 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 1
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/load_store_unit_i/data_we_q_tag
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 0
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 723 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 724 #############
###### JUMP TO ATTACK START ######
set start_sim "137260 ns"
run "137260 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137260 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 1
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/load_store_unit_i/data_we_q_tag
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 0
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 724 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 725 #############
###### JUMP TO ATTACK START ######
set start_sim "137300 ns"
run "137300 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137300 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 1
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/load_store_unit_i/data_we_q_tag
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 0
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 725 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 726 #############
###### JUMP TO ATTACK START ######
set start_sim "137340 ns"
run "137340 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137340 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 1
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/load_store_unit_i/data_we_q_tag
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 0
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 726 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 727 #############
###### JUMP TO ATTACK START ######
set start_sim "137140 ns"
run "137140 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137140 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 2
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/load_store_unit_i/rdata_offset_q_tag
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 0
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 727 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 728 #############
###### JUMP TO ATTACK START ######
set start_sim "137180 ns"
run "137180 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137180 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 2
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/load_store_unit_i/rdata_offset_q_tag
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 0
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 728 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 729 #############
###### JUMP TO ATTACK START ######
set start_sim "137220 ns"
run "137220 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137220 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 2
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/load_store_unit_i/rdata_offset_q_tag
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 0
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 729 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 730 #############
###### JUMP TO ATTACK START ######
set start_sim "137260 ns"
run "137260 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137260 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 2
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/load_store_unit_i/rdata_offset_q_tag
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 0
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 730 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 731 #############
###### JUMP TO ATTACK START ######
set start_sim "137300 ns"
run "137300 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137300 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 2
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/load_store_unit_i/rdata_offset_q_tag
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 0
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 731 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 732 #############
###### JUMP TO ATTACK START ######
set start_sim "137340 ns"
run "137340 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137340 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 2
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/load_store_unit_i/rdata_offset_q_tag
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 0
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 732 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 733 #############
###### JUMP TO ATTACK START ######
set start_sim "137140 ns"
run "137140 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137140 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 2
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/load_store_unit_i/rdata_offset_q_tag
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 1
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 733 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 734 #############
###### JUMP TO ATTACK START ######
set start_sim "137180 ns"
run "137180 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137180 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 2
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/load_store_unit_i/rdata_offset_q_tag
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 1
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 734 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 735 #############
###### JUMP TO ATTACK START ######
set start_sim "137220 ns"
run "137220 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137220 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 2
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/load_store_unit_i/rdata_offset_q_tag
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 1
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 735 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 736 #############
###### JUMP TO ATTACK START ######
set start_sim "137260 ns"
run "137260 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137260 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 2
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/load_store_unit_i/rdata_offset_q_tag
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 1
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 736 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 737 #############
###### JUMP TO ATTACK START ######
set start_sim "137300 ns"
run "137300 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137300 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 2
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/load_store_unit_i/rdata_offset_q_tag
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 1
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 737 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 738 #############
###### JUMP TO ATTACK START ######
set start_sim "137340 ns"
run "137340 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137340 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 2
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/load_store_unit_i/rdata_offset_q_tag
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 1
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 738 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 739 #############
###### JUMP TO ATTACK START ######
set start_sim "137140 ns"
run "137140 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137140 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 4
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/load_store_unit_i/rdata_q_tag
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 0
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 739 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 740 #############
###### JUMP TO ATTACK START ######
set start_sim "137180 ns"
run "137180 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137180 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 4
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/load_store_unit_i/rdata_q_tag
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 0
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 740 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 741 #############
###### JUMP TO ATTACK START ######
set start_sim "137220 ns"
run "137220 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137220 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 4
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/load_store_unit_i/rdata_q_tag
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 0
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 741 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 742 #############
###### JUMP TO ATTACK START ######
set start_sim "137260 ns"
run "137260 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137260 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 4
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/load_store_unit_i/rdata_q_tag
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 0
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 742 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 743 #############
###### JUMP TO ATTACK START ######
set start_sim "137300 ns"
run "137300 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137300 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 4
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/load_store_unit_i/rdata_q_tag
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 0
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 743 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 744 #############
###### JUMP TO ATTACK START ######
set start_sim "137340 ns"
run "137340 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137340 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 4
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/load_store_unit_i/rdata_q_tag
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 0
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 744 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 745 #############
###### JUMP TO ATTACK START ######
set start_sim "137140 ns"
run "137140 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137140 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 4
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/load_store_unit_i/rdata_q_tag
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 1
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 745 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 746 #############
###### JUMP TO ATTACK START ######
set start_sim "137180 ns"
run "137180 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137180 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 4
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/load_store_unit_i/rdata_q_tag
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 1
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 746 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 747 #############
###### JUMP TO ATTACK START ######
set start_sim "137220 ns"
run "137220 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137220 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 4
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/load_store_unit_i/rdata_q_tag
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 1
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 747 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 748 #############
###### JUMP TO ATTACK START ######
set start_sim "137260 ns"
run "137260 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137260 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 4
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/load_store_unit_i/rdata_q_tag
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 1
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 748 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 749 #############
###### JUMP TO ATTACK START ######
set start_sim "137300 ns"
run "137300 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137300 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 4
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/load_store_unit_i/rdata_q_tag
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 1
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 749 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 750 #############
###### JUMP TO ATTACK START ######
set start_sim "137340 ns"
run "137340 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137340 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 4
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/load_store_unit_i/rdata_q_tag
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 1
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 750 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 751 #############
###### JUMP TO ATTACK START ######
set start_sim "137140 ns"
run "137140 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137140 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 4
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/load_store_unit_i/rdata_q_tag
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 2
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 751 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 752 #############
###### JUMP TO ATTACK START ######
set start_sim "137180 ns"
run "137180 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137180 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 4
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/load_store_unit_i/rdata_q_tag
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 2
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 752 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 753 #############
###### JUMP TO ATTACK START ######
set start_sim "137220 ns"
run "137220 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137220 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 4
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/load_store_unit_i/rdata_q_tag
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 2
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 753 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 754 #############
###### JUMP TO ATTACK START ######
set start_sim "137260 ns"
run "137260 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137260 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 4
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/load_store_unit_i/rdata_q_tag
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 2
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 754 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 755 #############
###### JUMP TO ATTACK START ######
set start_sim "137300 ns"
run "137300 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137300 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 4
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/load_store_unit_i/rdata_q_tag
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 2
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 755 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 756 #############
###### JUMP TO ATTACK START ######
set start_sim "137340 ns"
run "137340 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137340 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 4
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/load_store_unit_i/rdata_q_tag
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 2
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 756 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 757 #############
###### JUMP TO ATTACK START ######
set start_sim "137140 ns"
run "137140 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137140 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 4
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/load_store_unit_i/rdata_q_tag
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 3
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 757 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 758 #############
###### JUMP TO ATTACK START ######
set start_sim "137180 ns"
run "137180 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137180 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 4
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/load_store_unit_i/rdata_q_tag
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 3
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 758 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 759 #############
###### JUMP TO ATTACK START ######
set start_sim "137220 ns"
run "137220 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137220 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 4
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/load_store_unit_i/rdata_q_tag
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 3
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 759 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 760 #############
###### JUMP TO ATTACK START ######
set start_sim "137260 ns"
run "137260 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137260 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 4
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/load_store_unit_i/rdata_q_tag
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 3
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 760 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 761 #############
###### JUMP TO ATTACK START ######
set start_sim "137300 ns"
run "137300 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137300 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 4
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/load_store_unit_i/rdata_q_tag
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 3
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 761 #############
# Restart the simulation
restart
#------------------------------------
##############################################################################
incr nb_sim
############# ATTACK 762 #############
###### JUMP TO ATTACK START ######
set start_sim "137340 ns"
run "137340 ns" ;# Saut vers la fenêtre d'attaque

set nb_cycle [expr [expr 137340 - $start] / 40]
set sim_active 1
##---------------------
###### FORCE VALUE ON FAULTED REGISTER ######
set threat "bitflip"
set width_threat 4
set faulted_register /tb/top_i/core_region_i/RISCV_CORE/load_store_unit_i/rdata_q_tag
set bit_flipped -1

### STATUS END ###
set status_end -1 

if {$threat == "bitflip"} {
    if {$width_threat == 1} {
        set value_curr_reg [examine -bin $faulted_register]
        set value [lindex [split $value_curr_reg b] 1]
        set bf [expr {$value^1}]
        set bit_flipped 0
        force -freeze $faulted_register $bf 0 -cancel "$half_periode ns"
    } else {
        set bit_attacked 3
        set bit_flipped $bit_attacked
        set value_curr_reg [examine -hex $faulted_register\[{$bit_attacked}\]]
        set value [lindex [split $value_curr_reg h] 1]
        set bitflip_faulted_register [expr $value^1]
        force -freeze $faulted_register\[{$bit_attacked}\] [concat $width_threat'h$bitflip_faulted_register] 0 -cancel "$half_periode ns"
    }
}

###### RUN SIM 100 cycles MAX or WHILE PC != 0x84 ######
while {$sim_active == 1} {
    run "$periode ns" ;# run 1 cycle
    incr nb_cycle

    set value_pc [examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/pc_id_o]

    #############  CHECKING SIM VALUES #############
    ## if conditions to stop the run cycles
    if {$nb_cycle > $cycle_ref} {
        ## CYCLE OVERFLOW : CRASH ##
        set sim_active 0
        set status_end 1
    } elseif {([expr {$value_pc} == {"32'h0000022c"}]) && ([expr {[examine -hex /tb/top_i/core_region_i/RISCV_CORE/if_stage_i/instr_rdata_id_o]} == {"32'hfa010113"}])} {
        ## INSN ILL HANDLER ##
        if {[expr {$cycle_ill_insn} == {[expr $now / 1000]}]} {
            # Illegal insn handler au même moment que simulation 0  : NOTHING #
            set status_end 2
        } else {
            # Illegal insn handler à un moment différent que simulation 0 : EXCEPTION DECALEE #
            set status_end 3
        }
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} == {$value_end_pc}])} {
        ## RAS ##
        set status_end 0
        set sim_active 0
    } elseif {($nb_cycle == $cycle_ref) && ([expr {$value_pc} != {$value_end_pc}])} {
        ## SUCCESS ? ##
        set status_end 4
        set sim_active 0
    }
}

#############  LOG #############
#---- INIT ----
set f [open $state_file a]
puts $f "\t\"simulation_$nb_sim\": {"

#---- Cycle Checking ----
puts $f "\t\t\t\"cycle_ref\": $cycle_ref," 
puts $f "\t\t\t\"cycle_ending\": $check_cycle,"

#---- TCR / TPR ----
puts $f "\t\t\t\"TPR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q]\","
puts $f "\t\t\t\"TCR\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q]\","

#---- Log Register File ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i/rf_reg\[{$j}\]]\","
}

#---- Log Register File Tag ----
for {set j 0} {$j < 32} {incr j} {
    puts $f "\t\t\t\"rf_tag$j\": \"[examine -hex /tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg\[{$j}\]]\","
}

#---- Log Registres du fichiers registres.yaml ----
foreach reg $reg_file_data {
    if {([expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tpr_q"}]
        && [expr {$reg != "/tb/top_i/core_region_i/RISCV_CORE/cs_registers_i/tcr_q"}]
        && ![string match "/tb/top_i/core_region_i/RISCV_CORE/id_stage_i/registers_i_tag/rf_reg*" $reg])
        && [expr {$reg != "-"}]
    } {
        set nom_reg_list [split $reg "/"]
        # if {[expr {$nom_reg_list[{[expr [llength $nom_reg_list] - 1]}] == "hc_o_32"}]}{
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 2]]\": \"[examine -hex $reg]\","
        # } else {
        #     puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
        # }
        puts $f "\t\t\t\"[lindex $nom_reg_list [expr [llength $nom_reg_list] - 1]]\": \"[examine -hex $reg]\","
    }
}

#---- Log faulted register: name, width, threat considered, when ----
if {$nb_sim != 0} {
    puts $f "\t\t\t\"faulted_register\": \"$faulted_register\","
    puts $f "\t\t\t\"size_faulted_register\": $width_threat,"
    puts $f "\t\t\t\"threat\": \"$threat\","
    if {[expr {$threat == "bitflip"}]} {
        puts $f "\t\t\t\"bit_flipped\": $bit_flipped,"
    }
    puts $f "\t\t\t\"cycle_attacked\": \"$start_sim\","
}
 
#---- Ending status ----
puts $f "\t\t\t\"simulation_end_time\": \"[expr {$now / 1000}] ns\","
puts $f "\t\t\t\"status_end\": $status_end"
puts $f "\t},"

#---- Close log ----
close $f

############# END SIM 762 #############
# Write date of end
set f [open $state_file a]
puts $f "\"end\": \"[clock format [clock seconds] -format "%Y/%m/%d:%H:%M:%S"]\""
puts $f "}"
close $f

# Exit the simulation
exit
#------------------------------------